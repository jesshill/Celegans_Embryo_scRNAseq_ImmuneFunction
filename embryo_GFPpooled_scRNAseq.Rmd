---
title: "embryo_intestine_scRNAseq"
author: "Jessica Hill"
date: 
output: html_document
---

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r warning=FALSE, message=FALSE}
# Install packages

install.packages('Seurat')
packageVersion('Seurat') # 5.3.1
install.packages('Matrix')
install.packages("hdf5r")
install.packages("clustree")
install.packages("tidyverse")
install.packages("patchwork")
install.packages("remotes")
install.packages("R.utils")


if (!require("BiocManager", quietly = TRUE))
     install.packages("BiocManager")
BiocManager::install(version = "3.22")

BiocManager::install("biomaRt")
BiocManager::install('multtest')
install.packages('metap')
install.packages('devtools')
install.packages('pheatmap')
```


```{r warning=FALSE, message=FALSE}
# Load packages

library(biomaRt)
library(Seurat)
library(ggplot2)
library(tidyverse)
library(patchwork)
library(clustree)
library(metap)
library(pheatmap)
library(tibble)
```


```{r}
# Load the data
emb.GFPpooled_v2.data <- Read10X_h5("./cellranger/all_GFP_v2/filtered_feature_bc_matrix.h5")

emb.ALLpooled_v2.data <- Read10X_h5("./cellranger/all_pooled_v2/filtered_feature_bc_matrix.h5")
```


```{r}
# Get filternames from "https://parasite.wormbase.org/biomart/martview"

# Connect to Wormbase Parasite Biomart
mart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)

# Query gene annotations 
genes.df <- getBM(mart = mart, 
      filters = c("species_id_1010", "gene_name"),
      value = list("caelegprjna13758", rownames(emb.ALLpooled_v2.data)),
      attributes = c('wbps_gene_id','external_gene_id', 'chromosome_name'))

# Identify mitochondrial genes
mitoList = genes.df[genes.df$chromosome_name == 'MtDNA', 'external_gene_id']

# Clean up the annotation table (removes chromosome column)
genes.df$chromosome_name = NULL

# Check annotation coverage
c(nrow(genes.df), nrow(emb.ALLpooled_v2.data))

# Count missing genes
nrow(emb.ALLpooled_v2.data)-nrow(genes.df)
```

```{r}
# Get filternames from "https://parasite.wormbase.org/biomart/martview"

# Connect to Wormbase Parasite Biomart
mart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)

# Query gene annotations
genes1.df <- getBM(mart = mart, 
      filters = c("species_id_1010", "gene_name"),
      value = list("caelegprjna13758", rownames(emb.GFPpooled_v2.data)),
      attributes = c('wbps_gene_id','external_gene_id', 'chromosome_name'))

# Identify mitochondrial genes
mitoList1 = genes1.df[genes1.df$chromosome_name == 'MtDNA', 'external_gene_id']

# Clean up the annotation table (removes chromosome column)
genes1.df$chromosome_name = NULL

# Check annotation coverage
c(nrow(genes1.df), nrow(emb.GFPpooled_v2.data))

# Count missing genes
nrow(emb.GFPpooled_v2.data)-nrow(genes1.df)
```


```{r}
# Filter the expression matrix to annotated genes only, so removing the missing genes (identified above) from the input matrix
emb.ALLpooled_v2.data.filt <- emb.ALLpooled_v2.data[rownames(emb.ALLpooled_v2.data) %in% genes.df$external_gene_id,]

# Check whether gene order matches between objects
identical(rownames(emb.ALLpooled_v2.data.filt), genes.df$external_gene_id)

# They do not, so use match to make sure they are in the same order and then verify with identical 
identical(rownames(emb.ALLpooled_v2.data.filt),
          genes.df[match(rownames(emb.ALLpooled_v2.data.filt), genes.df$external_gene_id),]$external_gene_id)

# Check for missing matches (sanity check), are there NAs?
sum(is.na(rownames(emb.ALLpooled_v2.data.filt)))

# Inspect the filtered matrix
head(emb.ALLpooled_v2.data.filt)
```

```{r}
# Filter the expression matrix to annotated genes only, so removing the missing genes (identified above) from the input matrix
emb.GFPpooled_v2.data.filt <- emb.GFPpooled_v2.data[rownames(emb.GFPpooled_v2.data) %in% genes1.df$external_gene_id,]

# Check whether gene order matches between objects
identical(rownames(emb.GFPpooled_v2.data.filt), genes1.df$external_gene_id)

# They do not, so use match to make sure they are in the same order and then verify with identical 
identical(rownames(emb.GFPpooled_v2.data.filt),
          genes1.df[match(rownames(emb.GFPpooled_v2.data.filt), genes1.df$external_gene_id),]$external_gene_id)

# Check for missing matches (sanity check), are there NAs?
sum(is.na(rownames(emb.GFPpooled_v2.data.filt)))

# Inspect the filtered matrix
head(emb.GFPpooled_v2.data.filt)
```


```{r}
# Extract the cell codes (barcode info with the trailing integer which signifies the order of the samples in the aggregation step)
cellcodes <- as.data.frame(emb.ALLpooled_v2.data.filt@Dimnames[[2]])

# Clean up barcode dataframe
colnames(cellcodes) <- "barcodes"
rownames(cellcodes) <- cellcodes$barcodes

# Assign replicate groups using barcode suffixes
cellcodes$rep_group <- dplyr::case_when(
  grepl("-(1|5)$", cellcodes$barcodes) ~ "Rep_1",
  grepl("-(2|6)$", cellcodes$barcodes) ~ "Rep_2",
  grepl("-(3|7)$", cellcodes$barcodes) ~ "Rep_3",
  grepl("-(4|8)$", cellcodes$barcodes) ~ "Rep_4",
  TRUE ~ "Unknown"
)

# Assign experimental condition (GFP vs Unsorted)
cellcodes$condition <- dplyr::case_when(
  grepl("-(1|2|3|4)$", cellcodes$barcodes) ~ "GFP",
  grepl("-(5|6|7|8)$", cellcodes$barcodes) ~ "Unsorted",
  TRUE ~ "Unknown"
)

# Examine the dataframe
view(cellcodes)
head(cellcodes)
```

```{r}
# Extract the cell codes (barcode info with the trailing integer which signifies the order of the samples in the aggregation step)
cellcodes_1 <- as.data.frame(emb.GFPpooled_v2.data.filt@Dimnames[[2]])

# Clean up barcode dataframe
colnames(cellcodes_1) <- "barcodes"
rownames(cellcodes_1) <- cellcodes_1$barcodes 

# Assign replicate groups using barcode suffixes
cellcodes_1$rep_group <- dplyr::case_when(
  grepl("-1$", cellcodes_1$barcodes) ~ "Rep_1",
  grepl("-2$", cellcodes_1$barcodes) ~ "Rep_2",
  grepl("-3$", cellcodes_1$barcodes) ~ "Rep_3",
  grepl("-4$", cellcodes_1$barcodes) ~ "Rep_4",
  TRUE ~ "Unknown"
)

# Assign experimental condition (GFP)
cellcodes_1$condition <- dplyr::case_when(
  grepl("-(1|2|3|4)$", cellcodes_1$barcodes) ~ "GFP",
  TRUE ~ "Unknown"
)

# Examine the dataframe
view(cellcodes_1)
head(cellcodes_1) 
```


```{r}
# Check data for mismatch, make sure that rownames(cellcodes) and colnames(counts) match
all(colnames(emb.ALLpooled_v2.data.filt) == rownames(cellcodes))
all(colnames(emb.GFPpooled_v2.data.filt) == rownames(cellcodes_1))
```


```{r}
# Set up the Seurat object. Initialize the Seurat object with the raw (non-normalized data)
emb.ALLpooled_v2 <- CreateSeuratObject(counts = emb.ALLpooled_v2.data.filt, project = "emb.ALLpooled_v2", min.cells = 3, min.features = 200, meta.data = cellcodes)

view(emb.ALLpooled_v2@meta.data)
```

```{r}
# Set up the Seurat object. Initialize the Seurat object with the raw (non-normalized data)
emb.GFPpooled_v2 <- CreateSeuratObject(counts = emb.GFPpooled_v2.data.filt, project = "emb.GFPpooled_v2", min.cells = 3, min.features = 200, meta.data = cellcodes_1)

view(emb.GFPpooled_v2@meta.data)
```


```{r}
# Takes the RNA assay in our Seurat object and splits it into multiply layers (sub-assays-->one per rep_group), so each replicate can be processed independently (normalized, scaled, variable feature detection, etc. and then integrated)
emb.ALLpooled_v2[["RNA"]] <- split(emb.ALLpooled_v2[["RNA"]], f = emb.ALLpooled_v2$rep_group)

# Now check the layers (raw data only at this point 'counts.')
emb.ALLpooled_v2
```

```{r}
# Takes the RNA assay in our Seurat object and splits it into multiply layers (sub-assays-->one per rep_group), so each replicate can be processed independently (normalization, scaling, variable feature detection, etc. and then integrated)
emb.GFPpooled_v2[["RNA"]] <- split(emb.GFPpooled_v2[["RNA"]], f = emb.GFPpooled_v2$rep_group)

# Now check the layers (raw data only at this point 'counts.')
emb.GFPpooled_v2
```


```{r}
## QC - Peak at the data 
# `nFeature_RNA` is number of genes detected in each cell. 
# `nCount_RNA` is total number of molecules detected within a cell (AKA total UMIs per cell)
# Low `nFeature_RNA` indicates that the cell may be dead or dying or an empty droplet
# High `nCount_RNA` and/or `nFeature_RNA` indicates that the "cell" may in fact be a doublet (or multiplet)

view(emb.ALLpooled_v2@meta.data)
head(emb.ALLpooled_v2@meta.data, 5)
```

```{r}
## QC - Peak at the data 
# `nFeature_RNA` is number of genes detected in each cell. 
# `nCount_RNA` is total number of molecules detected within a cell (AKA total UMIs per cell)
# Low `nFeature_RNA` indicates that the cell may be dead or dying or an empty droplet
# High `nCount_RNA` and/or `nFeature_RNA` indicates that the "cell" may in fact be a doublet (or multiplet)

view(emb.GFPpooled_v2@meta.data)
head(emb.GFPpooled_v2@meta.data, 5)
```


```{r}
# QC - Mitochondrial genome percentage 
mitoIndices <- rownames(emb.ALLpooled_v2)[rownames(emb.ALLpooled_v2) %in% mitoList]

emb.ALLpooled_v2[["percent.mt"]] <- PercentageFeatureSet(emb.ALLpooled_v2, features = mitoIndices)
```

```{r}
# QC - Mitochondrial genome percentage
mitoIndices_1 <- rownames(emb.GFPpooled_v2)[rownames(emb.GFPpooled_v2) %in% mitoList1]

emb.GFPpooled_v2[["percent.mt"]] <- PercentageFeatureSet(emb.GFPpooled_v2, features = mitoIndices_1)
```


```{r}
#Visualize QC metrics as a violin plot

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.VlnPlot.pdf", height = 6, width = 9)
VlnPlot(emb.ALLpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), layer = "counts", ncol = 3)
dev.off()
```

```{r}
#Visualize QC metrics as a violin plot

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VlnPlot.pdf", height = 6, width = 9)
VlnPlot(emb.GFPpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), layer = "counts", ncol = 3)
dev.off()
```


```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeatureScatter.pdf", height = 6, width = 9)
plot1 <- FeatureScatter(emb.ALLpooled_v2, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.ALLpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
dev.off()
```

```{r}
# FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeatureScatter.pdf", height = 6, width = 9)
plot1 <- FeatureScatter(emb.GFPpooled_v2, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.GFPpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
dev.off()
```


```{r}
# Filter based on features. Cells being filtered due to mito percent. 
sum(emb.ALLpooled_v2$percent.mt > 50)/ length(emb.ALLpooled_v2$percent.mt)
emb.ALLpooled_v2 <- subset(emb.ALLpooled_v2, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)
```

```{r}
# Filter based on features. Cells being filtered due to mito percent.
sum(emb.GFPpooled_v2$percent.mt > 50)/ length(emb.GFPpooled_v2$percent.mt)
emb.GFPpooled_v2 <- subset(emb.GFPpooled_v2, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)
```


```{r}
# Visualize after filtering

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.VlnPlot.filt.pdf", height = 6, width = 9)
VlnPlot(emb.ALLpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), layer = "counts")
dev.off()

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeatureScatter.filt.pdf", height = 6, width = 9)
FeatureScatter(emb.ALLpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
dev.off()
```

```{r}
# Visualize after filtering

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VlnPlot.filt.pdf", height = 6, width = 9)
VlnPlot(emb.GFPpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), layer = "counts")
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeatureScatter.filt.pdf", height = 6, width = 9)
FeatureScatter(emb.GFPpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
dev.off()
```


```{r}
# Check out the metadata, inspect QC metrics, labels, etc. 
view(emb.ALLpooled_v2@meta.data) 
hist(emb.ALLpooled_v2$nFeature_RNA) 
hist(emb.ALLpooled_v2$nCount_RNA) 

view(emb.ALLpooled_v2@assays$RNA$counts.Rep_1)
view(emb.ALLpooled_v2@assays$RNA$counts.Rep_2)
view(emb.ALLpooled_v2@assays$RNA$counts.Rep_3)
view(emb.ALLpooled_v2@assays$RNA$counts.Rep_4)

# Extract the raw count matrix (genes x cells) from the RNA assay
exp_matrix <- as.matrix(emb.ALLpooled_v2@assays$RNA$counts.Rep_1)
# Sum counts for each gene across all cells
total_cts_per_gene <- rowSums(exp_matrix)
# Count how many genes have a total expression count of exactly one, indicating they are expressed in only a single cell at a single UMI
genes_express_only_once <- sum(total_cts_per_gene==1)

exp_matrix2 <- as.matrix(emb.ALLpooled_v2@assays$RNA$counts.Rep_2)
total_cts_per_gene2 <- rowSums(exp_matrix2)
genes_express_only_once2 <- sum(total_cts_per_gene2==1)

exp_matrix3 <- as.matrix(emb.ALLpooled_v2@assays$RNA$counts.Rep_3)
total_cts_per_gene3 <- rowSums(exp_matrix3)
genes_express_only_once3 <- sum(total_cts_per_gene3==1)

exp_matrix4 <- as.matrix(emb.ALLpooled_v2@assays$RNA$counts.Rep_4)
total_cts_per_gene4 <- rowSums(exp_matrix4)
genes_express_only_once4 <- sum(total_cts_per_gene4==1)
```

```{r}
# Check out the metadata, inspect QC metrics, labels, etc. 
view(emb.GFPpooled_v2@meta.data)
hist(emb.GFPpooled_v2$nFeature_RNA)
hist(emb.GFPpooled_v2$nCount_RNA)

view(emb.GFPpooled_v2@assays$RNA$counts.Rep_1)
view(emb.GFPpooled_v2@assays$RNA$counts.Rep_2)
view(emb.GFPpooled_v2@assays$RNA$counts.Rep_3)
view(emb.GFPpooled_v2@assays$RNA$counts.Rep_4)

# Extract the raw count matrix (genes x cells) from the RNA assay
exp_matrix <- as.matrix(emb.GFPpooled_v2@assays$RNA$counts.Rep_1)
# Sum counts for each gene across all cells
total_cts_per_gene <- rowSums(exp_matrix)
# Count how many genes have a total expression count of exactly one, indicating they are expressed in only a single cell at a single UMI
genes_express_only_once <- sum(total_cts_per_gene==1)

exp_matrix2 <- as.matrix(emb.GFPpooled_v2@assays$RNA$counts.Rep_2)
total_cts_per_gene2 <- rowSums(exp_matrix2)
genes_express_only_once2 <- sum(total_cts_per_gene2==1)

exp_matrix3 <- as.matrix(emb.GFPpooled_v2@assays$RNA$counts.Rep_3)
total_cts_per_gene3 <- rowSums(exp_matrix3)
genes_express_only_once3 <- sum(total_cts_per_gene3==1)

exp_matrix4 <- as.matrix(emb.GFPpooled_v2@assays$RNA$counts.Rep_4)
total_cts_per_gene4 <- rowSums(exp_matrix4)
genes_express_only_once4 <- sum(total_cts_per_gene4==1)
```


```{r}
# Normalize the data: after removing unwanted cells from the dataset normalize the data. By default, a global-scaling normalization method "LogNormalize" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 is the default), and log-transforms the result.

# Normalized values are stored in emb.ALLpooled_v2@assays$RNA$data.Rep_1

emb.ALLpooled_v2 <- NormalizeData(emb.ALLpooled_v2, normalization.method = "LogNormalize", scale.factor = 10000)
```

```{r}
# Normalize the data: after removing unwanted cells from the dataset normalize the data. By default, a global-scaling normalization method "LogNormalize" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 is the default), and log-transforms the result.

# Normalized values are stored in emb.GFPpooled_v2@assays$RNA$data.Rep_1

emb.GFPpooled_v2 <- NormalizeData(emb.GFPpooled_v2, normalization.method = "LogNormalize", scale.factor = 10000)
```


```{r}
# Feature selection: Identify highly variable features to focus on in downstream analysis
emb.ALLpooled_v2 <- FindVariableFeatures(emb.ALLpooled_v2, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10_all <- head(VariableFeatures(emb.ALLpooled_v2), 10)

# plot variable features with and without labels
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.VarFeatures.pdf", height = 6, width = 9)
plot1 <- VariableFeaturePlot(emb.ALLpooled_v2)
LabelPoints(plot = plot1, points = top10_all, repel = TRUE)
dev.off()
```

```{r}
# Feature selection: Identify highly variable features to focus on in downstream analysis
emb.GFPpooled_v2 <- FindVariableFeatures(emb.GFPpooled_v2, selection.method = "vst", nfeatures = 2000)

top10_GFP <- head(VariableFeatures(emb.GFPpooled_v2), 10)

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VarFeatures.pdf", height = 6, width = 9)
plot1 <- VariableFeaturePlot(emb.GFPpooled_v2)
LabelPoints(plot = plot1, points = top10_GFP, repel = TRUE)
dev.off()
```


```{r}
# Scaling the data: Apply a linear transformation ("scaling") prior to dimensional reduction, PCA. Shifts the expression of each gene, so that the mean expression across cells is 0. Scales the expression of each gene, so that the variance across cells is 1. This gives equal weight in downstream analysis, so that highly expressed genes don't dominate.
all.genes <- rownames(emb.ALLpooled_v2)
emb.ALLpooled_v2 <- ScaleData(emb.ALLpooled_v2, features = all.genes)
```

```{r}
# Scaling the data: Apply a linear transformation ("scaling") prior to dimensional reduction, PCA. Shifts the expression of each gene, so that the mean expression across cells is 0. Scales the expression of each gene, so that the variance across cells is 1. This gives equal weight in downstream analysis, so that highly expressed genes don't dominate.
all.genes_1 <- rownames(emb.GFPpooled_v2)
emb.GFPpooled_v2 <- ScaleData(emb.GFPpooled_v2, features = all.genes_1)
```


```{r}
# Linear dimensional reduction: Perform PCA on the scaled data. By default, only the previously determined variable features are used as input. 

# default: seed.use = 42

emb.ALLpooled_v2 <- RunPCA(emb.ALLpooled_v2, features = VariableFeatures(object = emb.ALLpooled_v2))
```

```{r}
# Linear dimensional reduction: Perform PCA on the scaled data. By default, only the previously determined variable features are used as input.

# default: seed.use = 42

emb.GFPpooled_v2 <- RunPCA(emb.GFPpooled_v2, features = VariableFeatures(object = emb.GFPpooled_v2))
```


```{r}
# Examine and visualize PCA results a few different ways
print(emb.ALLpooled_v2[["pca"]], dims = 1:5, nfeatures = 10)
```

```{r}
# Examine and visualize PCA results a few different ways
print(emb.GFPpooled_v2[["pca"]], dims = 1:5, nfeatures = 10)
```


```{r}
# top genes associated with reduction components
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.DimLoadings.pdf", height = 6, width = 9)
VizDimLoadings(emb.ALLpooled_v2, dims = 1:2, reduction = "pca")
dev.off()
```

```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.DimLoadings.pdf", height = 6, width = 9)
VizDimLoadings(emb.GFPpooled_v2, dims = 1:2, reduction = "pca")
dev.off()
```


```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.DimPlot.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "pca")
dev.off()
```

```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.DimPlot.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "pca")
dev.off()
```


```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.HeatMap1.pdf", height = 6, width = 9)
DimHeatmap(emb.ALLpooled_v2, dims = 1, cells = 500, balanced = TRUE)
dev.off()
```

```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.HeatMap1.pdf", height = 6, width = 9)
DimHeatmap(emb.GFPpooled_v2, dims = 1, cells = 500, balanced = TRUE)
dev.off()
```


```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.HeatMap1-6.pdf", height = 6, width = 9)
DimHeatmap(emb.ALLpooled_v2, dims = 1:6, cells = 500, balanced = TRUE)
dev.off()
```

```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.HeatMap1-6.pdf", height = 6, width = 9)
DimHeatmap(emb.GFPpooled_v2, dims = 1:6, cells = 500, balanced = TRUE)
dev.off()
```


```{r}
# Determine dataset dimensionality: To overcome technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a ‘metafeature’ that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. But how many components should we choose to include? 

# Seurat implements a resampling test inspired by the JackStraw procedure. We randomly permute a subset of the data (1% by default) and rerun PCA, constructing a ‘null distribution’ of feature scores, and repeat this procedure. We identify ‘significant’ PCs as those who have a strong enrichment of low p-value features.

emb.ALLpooled_v2 <- JackStraw(emb.ALLpooled_v2, num.replicate = 100)
emb.ALLpooled_v2 <- ScoreJackStraw(emb.ALLpooled_v2, dims = 1:20)
```

```{r}
# Determine dataset dimensionality: To overcome technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a ‘metafeature’ that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. But how many components should we choose to include? 

# Seurat implements a resampling test inspired by the JackStraw procedure. We randomly permute a subset of the data (1% by default) and rerun PCA, constructing a ‘null distribution’ of feature scores, and repeat this procedure. We identify ‘significant’ PCs as those who have a strong enrichment of low p-value features.
emb.GFPpooled_v2 <- JackStraw(emb.GFPpooled_v2, num.replicate = 100)
emb.GFPpooled_v2 <- ScoreJackStraw(emb.GFPpooled_v2, dims = 1:20)
```


```{r}
# The JackStrawPlot() function provides a visualization tool for comparing the distribution of p-values for each PC with a uniform distribution (dashed line). ‘Significant’ PCs will show a strong enrichment of features with low p-values (solid curve above the dashed line). 

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.JackStrawPlot.pdf", height = 6, width = 9)
JackStrawPlot(emb.ALLpooled_v2, dims = 1:20)
dev.off()
```

```{r}
# The JackStrawPlot() function provides a visualization tool for comparing the distribution of p-values for each PC with a uniform distribution (dashed line). ‘Significant’ PCs will show a strong enrichment of features with low p-values (solid curve above the dashed line). 

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.JackStrawPlot.pdf", height = 6, width = 9)
JackStrawPlot(emb.GFPpooled_v2, dims = 1:20)
dev.off()
```


```{r}
# An alternative heuristic method generates an ‘Elbow plot’: a ranking of principle components based on the percentage of variance explained by each one. 

# The elbow plot is helpful when determining how many PCs we need to capture the majority of the variation in the data. The elbow plot visualizes the standard deviation of each PC. Where the elbow appears is usually the threshold for identifying the majority of the variation. However, this method can be a bit subjective about where the elbow is located.

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.ElbowPlot.pdf", height = 6, width = 9)
ElbowPlot(emb.ALLpooled_v2)
dev.off()
```

```{r}
# An alternative heuristic method generates an ‘Elbow plot’: a ranking of principle components based on the percentage of variance explained by each one. 

# The elbow plot is helpful when determining how many PCs we need to capture the majority of the variation in the data. The elbow plot visualizes the standard deviation of each PC. Where the elbow appears is usually the threshold for identifying the majority of the variation. However, this method can be a bit subjective about where the elbow is located.

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ElbowPlot.pdf", height = 6, width = 9)
ElbowPlot(emb.GFPpooled_v2)
dev.off()
```


```{r}
# Cluster the cells: Seurat applies a graph-based clustering approach.

# Seurat first constructs a KNN graph based on the euclidean distance in PCA space, and refines the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset.

# To cluster the cells, Seurat then applies modularity optimization techniques such as the Louvain algorithm (default) or SLM, to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters() function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters.

emb.ALLpooled_v2 <- FindNeighbors(emb.ALLpooled_v2, dims = 1:20, reduction = "pca")

# deviation form seurat pipeline: generate a vector of different resolutions to see which one performs best 
emb.ALLpooled_v2.clust <- FindClusters(
  object = emb.ALLpooled_v2,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:20,
  save.SNN = TRUE)

## Now use Clustree to build a clustering tree based on the chosen resolutions specified above 
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.Clustree.pdf", height = 6, width = 9)
clustree(emb.ALLpooled_v2.clust, prefix = "RNA_snn_res.")
dev.off()

# can also see how the different resolutions look like this

DimPlot(emb.ALLpooled_v2.clust, group.by = "RNA_snn_res.0.8", label = TRUE)
```

```{r}
# Cluster the cells: Seurat applies a graph-based clustering approach.

# Seurat first constructs a KNN graph based on the euclidean distance in PCA space, and refines the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset.

# To cluster the cells, Seurat then applies modularity optimization techniques such as the Louvain algorithm (default) or SLM, to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters() function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters.

emb.GFPpooled_v2 <- FindNeighbors(emb.GFPpooled_v2, dims = 1:5, reduction = "pca")

# deviation form seurat pipeline: generate a vector of different resolutions to see which one performs best 
emb.GFPpooled_v2.clust <- FindClusters(
  object = emb.GFPpooled_v2,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:5,
  save.SNN = TRUE)

## Now use Clustree to build a clustering tree based on the chosen resolutions specified above

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.Clustree.pdf", height = 6, width = 9)
clustree(emb.GFPpooled_v2.clust, prefix = "RNA_snn_res.")
dev.off()

# can also see how the different resolutions look like this
DimPlot(emb.GFPpooled_v2.clust, group.by = "RNA_snn_res.0.8", label = TRUE)
```


```{r}
# now choose the appropriate resolution for the given dimensions using the Clustree data
emb.ALLpooled_v2 <- FindClusters(emb.ALLpooled_v2, resolution = 1.2, cluster.name = "unintegrated_clusters")
```

```{r}
# now choose the appropriate resolution for the given dimensions using the Clustree data
emb.GFPpooled_v2 <- FindClusters(emb.GFPpooled_v2, resolution = 1.2, cluster.name = "unintegrated_clusters")
```


```{r}
# Run non-linear dimensional reduction (UMAP) and visualize/explore data: The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP or tSNE, it is suggested to use the same PCs as input to the clustering analysis.

emb.ALLpooled_v2 <- RunUMAP(emb.ALLpooled_v2, dims = 1:20, reduction = "pca", reduction.name = "umap.unintegrated")
```

```{r}
# Run non-linear dimensional reduction (UMAP) and visualize/explore data: The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP or tSNE, it is suggested to use the same PCs as input to the clustering analysis.

emb.GFPpooled_v2 <- RunUMAP(emb.GFPpooled_v2, dims = 1:5, reduction = "pca", reduction.name = "umap.unintegrated")
```


```{r}
# Set `label = TRUE` or use the LabelClusters function to help label individual clusters

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.UMAP.unint.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "umap.unintegrated", group.by = c("rep_group", "unintegrated_clusters"), label = TRUE, label.size = 4, pt.size = 1)

#label.box = TRUE,
# + theme(axis.title.x = element_text(size = 20),
#         axis.ticks.x = element_line(size = 6),
#         axis.title.y = element_text(size = 20),
#         axis.ticks.y = element_line(size = 6),
#         legend.text = element_text(size = 20))
dev.off()



pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.UMAP.unint.rep.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "umap.unintegrated", split.by = "rep_group", pt.size = 1)
#label = TRUE, label.size = 4,
dev.off()
```
```{r}
# Set `label = TRUE` or use the LabelClusters function to help label individual clusters

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.unint.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", group.by = c("rep_group", "unintegrated_clusters"), label = TRUE, label.size = 4, pt.size = 1) 

# label.box = TRUE,
# + theme(axis.title.x = element_text(size = 20),
#         axis.ticks.x = element_line(size = 6),
#         axis.title.y = element_text(size = 20),
#         axis.ticks.y = element_line(size = 6),
#         legend.text = element_text(size = 20))
dev.off()



pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.unint.rep.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", split.by = "rep_group", pt.size = 1)
#label = TRUE, label.size = 4,
dev.off()
```


```{r}
# Perform integration:  Aims to return a single dimensional reduction that captures the shared sources of variance across multiple layers, so that cells in a similar biological state will cluster. The method returns a dimensional reduction (i.e. integrated.cca, harmony) which can be used for visualization and unsupervised clustering analysis.

set.seed(42) # this will match the default seed.use = 42 for RunPCR

emb.ALLpooled_v2 <- IntegrateLayers(object = emb.ALLpooled_v2, method = CCAIntegration, orig.reduction = "pca", new.reduction = "integrated.cca", verbose = FALSE)

emb.ALLpooled_v2 <- FindNeighbors(emb.ALLpooled_v2, reduction = "integrated.cca", dims = 1:20)

emb.ALLpooled_v2 <- FindClusters(emb.ALLpooled_v2, resolution = 1.2, cluster.name = "cca_clusters")

emb.ALLpooled_v2 <- RunUMAP(emb.ALLpooled_v2, reduction = "integrated.cca", dims = 1:20, reduction.name = "umap.cca")


pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.UMAP.int.cca.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "umap.cca", group.by = c("rep_group", "cca_clusters"), label = TRUE, label.size = 4, pt.size = 1)
dev.off()

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.UMAP.int.cca.rep.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "umap.cca", split.by = "rep_group", label.size = 4, pt.size = 1)
dev.off()


# re-join layers after integration
emb.ALLpooled_v2[["RNA"]] <- JoinLayers(emb.ALLpooled_v2[["RNA"]])
```

```{r}
# Perform integration:  Aims to return a single dimensional reduction that captures the shared sources of variance across multiple layers, so that cells in a similar biological state will cluster. The method returns a dimensional reduction (i.e. integrated.cca, harmony) which can be used for visualization and unsupervised clustering analysis.

set.seed(42) # this will match the default seed.use = 42 for RunPCR

emb.GFPpooled_v2 <- IntegrateLayers(object = emb.GFPpooled_v2, method = CCAIntegration, orig.reduction = "pca", new.reduction = "integrated.cca", verbose = FALSE)


emb.GFPpooled_v2 <- FindNeighbors(emb.GFPpooled_v2, reduction = "integrated.cca", dims = 1:5)

emb.GFPpooled_v2 <- FindClusters(emb.GFPpooled_v2, resolution = 1.2, cluster.name = "cca_clusters")

emb.GFPpooled_v2 <- RunUMAP(emb.GFPpooled_v2, reduction = "integrated.cca", dims = 1:5, reduction.name = "umap.cca")


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.int.cca.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.cca", group.by = c("rep_group", "cca_clusters"), label.size = 4, pt.size = 1)
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.int.cca.rep.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.cca", split.by = "rep_group", label.size = 4, pt.size = 1)
dev.off()


# re-join layers after integration
emb.GFPpooled_v2[["RNA"]] <- JoinLayers(emb.GFPpooled_v2[["RNA"]])
```


```{r}
emb.GFPpooled_v2@reductions$pca
emb.GFPpooled_v2@reductions$umap.unintegrated
emb.GFPpooled_v2@reductions$integrated.cca
emb.GFPpooled_v2@reductions$umap.cca


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.pca.rep.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "pca", split.by = "rep_group")
dev.off()

DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", split.by = "rep_group") #already have dont need to save again 

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.cca.rep.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "integrated.cca", split.by = "rep_group")
dev.off()

DimPlot(emb.GFPpooled_v2, reduction = "umap.cca", split.by = "rep_group") #already have dont need to save again 
```


```{r}
# output the metadata for each gene
# `nFeature_RNA` is the number of genes detected in each cell. 
# `nCount_RNA` is the total number of molecules detected within a cell (AKA total UMIs per cell)

write.csv(emb.GFPpooled_v2@meta.data,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2_meta.data.csv", row.names = TRUE)
```

```{r}
# output total gene list for cells in clusters (not just variable features)
# this will be the normalized and stabalized data

write.csv(emb.GFPpooled_v2@assays$RNA$data,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.csv", row.names = TRUE)
```


```{r}
# Find differentially expressed features (cluster biomarkers): Find markers that define clusters via differential expression. By default, Seurat identifies positive and negative markers of a single cluster (specified in ident.1) compared to all other cells. 'FindAllMarkers()' automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

# The 'min.pct' argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the 'thresh.test' argument requires a feature to be differentially expressed (on average) by some amount between the two groups. 'max.cells.per.ident' can also be set and will downsample each identity class to have no more cells than whatever this is set to. 

# find markers for every cluster compared to all remaining cells, report only the positive
emb.GFPpooled_v2.markers <- FindAllMarkers(emb.GFPpooled_v2, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

# write the marker gene list for each cluster 
write.csv(emb.GFPpooled_v2.markers,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2_markers.csv", row.names = TRUE)

# pct.1 = The fraction of cells in the target cluster (the cluster listed in the cluster column) that have non-zero expression of the gene.
# pct.2 = The fraction of cells in all other cells (i.e., all remaining clusters combined) that have non-zero expression of the gene.

# peek at the top marker genes for each cluster 
emb.GFPpooled_v2.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% slice_max(n = 3, order_by = avg_log2FC) 
```

```{r}
# Find differentially expressed features (cluster biomarkers): Find markers that define clusters via differential expression. By default, Seurat identifies positive and negative markers of a single cluster (specified in ident.1) compared to all other cells. 'FindAllMarkers()' automates this process for all clusters, but you can also test groups of clusters vs. each other, or against all cells.

# The 'min.pct' argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the 'thresh.test' argument requires a feature to be differentially expressed (on average) by some amount between the two groups. 'max.cells.per.ident' can also be set and will downsample each identity class to have no more cells than whatever this is set to. 

# find markers for every cluster compared to all remaining cells, report only the positive
emb.ALLpooled_v2.markers <- FindAllMarkers(emb.ALLpooled_v2, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

# write the marker gene list for each cluster 
write.csv(emb.ALLpooled_v2.markers,"./Seurat_output/all_pooled_v2/emb.ALLpooled_v2_markers.csv", row.names = TRUE)

# pct.1 = The fraction of cells in the target cluster (the cluster listed in the cluster column) that have non-zero expression of the gene.
# pct.2 = The fraction of cells in all other cells (i.e., all remaining clusters combined) that have non-zero expression of the gene.

# peek at the top marker genes for each cluster 
emb.ALLpooled_v2.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% slice_max(n = 3, order_by = avg_log2FC) 
```


```{r}
# checking which clusters are intestinal based on the expression of known intestine marker genes

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeaturePlot.INTmarkergenes.umap-cca.pdf", height = 6, width = 9)
FeaturePlot(emb.ALLpooled_v2, reduction = "umap.cca", features = c("elt-2", "elt-7", "ges-1", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)
dev.off()

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeaturePlot.INTmarkergenes.umap-unint.pdf", height = 6, width = 9)
FeaturePlot(emb.ALLpooled_v2, reduction = "umap.unintegrated", features = c("elt-2", "elt-7", "ges-1", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)
dev.off()
```
```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeaturePlot.alltissuemarkergenes.umap-cca.pdf", height = 12, width = 12)
FeaturePlot(emb.ALLpooled_v2, reduction = "umap.cca", features = c("elt-2", "elt-7", "ges-1", "glh-1", "nos-1", "pgl-1", "myo-3", "pat-10", "mls-1", "rab-3", "odr-2",  "mec-7", "myo-2", "tnc-2", "phat-2", "elt-1", "elt-3", "dpy-7"), ncol = 3, coord.fixed = TRUE)
dev.off()

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeaturePlot.alltissuemarkergenes.umap-unint.pdf", height = 12, width = 12)
FeaturePlot(emb.ALLpooled_v2, reduction = "umap.unintegrated", features = c("elt-2", "elt-7", "ges-1", "glh-1", "nos-1", "pgl-1", "myo-3", "pat-10", "mls-1", "rab-3", "odr-2",  "mec-7", "myo-2", "tnc-2", "phat-2", "elt-1", "elt-3", "dpy-7"), ncol = 3, coord.fixed = TRUE)
dev.off()


#VlnPlot(object = emb.ALLpooled_v2, features = c("ugt-14", "c10c5.4", "acp-2", "end-1"))
#VlnPlot(object = emb.ALLpooled_v2, features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"))
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeaturePlot.INTmarkergenes.umap-cca.pdf", height = 6, width = 9)
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.cca", features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeaturePlot.INTmarkergenes.umap-unint.pdf", height = 6, width = 9)
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VlnPlot.INTmarkergenes.pdf", height = 9, width = 12)
VlnPlot(object = emb.GFPpooled_v2, features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"), ncol = 3)
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.DimPlot.umap-cca.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.cca", group.by = "cca_clusters", label = TRUE, label.size = 6, pt.size = 1)
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.DimPlot.umap-unint.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", group.by = "unintegrated_clusters", label = TRUE, label.size = 6, pt.size = 1)
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeaturePlot.alltissuemarkergenes.umap-unint.pdf", height = 12, width = 12)
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", features = c("elt-2", "elt-7", "ges-1", "glh-1", "nos-1", "pgl-1", "myo-3", "pat-10", "mls-1", "rab-3", "odr-2",  "mec-7", "myo-2", "tnc-2", "phat-2", "elt-1", "elt-3", "dpy-7"), ncol = 3, coord.fixed = TRUE)
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeaturePlot.alltissuemarkergenes.umap-cca.pdf", height = 12, width = 12)
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.cca", features = c("elt-2", "elt-7", "ges-1", "glh-1", "nos-1", "pgl-1", "myo-3", "pat-10", "mls-1", "rab-3", "odr-2",  "mec-7", "myo-2", "tnc-2", "phat-2", "elt-1", "elt-3", "dpy-7"), ncol = 3, coord.fixed = TRUE)
dev.off()



pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VlnPlot.AllTissueMarkerGenes.pdf", height = 20, width = 24)
VlnPlot(object = emb.GFPpooled_v2, features = c("elt-2", "elt-7", "ges-1", "glh-1", "nos-1", "pgl-1", "myo-3", "pat-10", "mls-1", "rab-3", "odr-2",  "mec-7", "myo-2", "tnc-2", "phat-2", "elt-1", "elt-3", "dpy-7"), ncol = 3)
dev.off()
```


```{r}
# Remove contamination cluster(s)
# (Loose filtering) contamination clusters we want to remove = 0, 2, 3, 6, 7, 8, 15, 16  
emb.GFPpooled_v2.filteredClusters <- subset(emb.GFPpooled_v2, idents = c('0', '2', '3', '6', '7', '8', '15', '16'), invert = TRUE)

# Re-run PCA and clustering 
emb.GFPpooled_v2.filteredClusters <- RunPCA(emb.GFPpooled_v2.filteredClusters)

ElbowPlot(emb.GFPpooled_v2.filteredClusters)

emb.GFPpooled_v2.filteredClusters <- FindNeighbors(emb.GFPpooled_v2.filteredClusters, dims = 1:5, reduction = "pca")


emb.GFPpooled_v2.filteredClusters.clust <- FindClusters(
  object = emb.GFPpooled_v2.filteredClusters,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:5,
  save.SNN = TRUE)
clustree(emb.GFPpooled_v2.filteredClusters.clust, prefix = "RNA_snn_res.")


emb.GFPpooled_v2.filteredClusters <- FindClusters(emb.GFPpooled_v2.filteredClusters, resolution = 1.2, cluster.name = "filtered_clusters")

emb.GFPpooled_v2.filteredClusters <- RunUMAP(emb.GFPpooled_v2.filteredClusters, dims = 1:5, reduction = "pca", reduction.name = "umap.filtered")

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClusters.UMAP.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2.filteredClusters, reduction = "umap.filtered", label = TRUE, label.size = 7, pt.size = 1)
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClusters.UMAP-rep.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2.filteredClusters, reduction = "umap.filtered", split.by = "rep_group")
dev.off()
```


```{r}
#check clusters for expression of intestine marker genes
FeaturePlot(emb.GFPpooled_v2.filteredClusters, reduction = "umap.filtered", features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)

VlnPlot(object = emb.GFPpooled_v2.filteredClusters, features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"))

#check clusters for expression of all tissue marker genes

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClusters.FeaturePlot.AllTissueMarkerGenes.pdf", height = 20, width = 24)
FeaturePlot(emb.GFPpooled_v2.filteredClusters, reduction = "umap.filtered", features = c("elt-2", "elt-7", "ges-1", "glh-1", "nos-1", "pgl-1", "rab-3", "odr-2",  "mec-7", "myo-3", "pat-10", "lev-11", "myo-2", "tnc-2", "phat-2", "elt-1", "elt-3", "dpy-7"), ncol = 3, coord.fixed = TRUE)
dev.off()
```


```{r}
# Remove more contamination cluster(s) AS NEEDED 
# (Loose filtering) contamination clusters we want to remove = 6, 8, 12, 16  
emb.GFPpooled_v2.filteredClustersFINAL <- subset(emb.GFPpooled_v2.filteredClusters, idents = c('6', '8', '12', '16'), invert = TRUE)

# Re-run PCA and clustering 
emb.GFPpooled_v2.filteredClustersFINAL <- RunPCA(emb.GFPpooled_v2.filteredClustersFINAL)

ElbowPlot(emb.GFPpooled_v2.filteredClustersFINAL)

emb.GFPpooled_v2.filteredClustersFINAL <- FindNeighbors(emb.GFPpooled_v2.filteredClustersFINAL, dims = 1:5, reduction = "pca")


emb.GFPpooled_v2.filteredClustersFINAL.clust <- FindClusters(
  object = emb.GFPpooled_v2.filteredClustersFINAL,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:5,
  save.SNN = TRUE)
clustree(emb.GFPpooled_v2.filteredClustersFINAL.clust, prefix = "RNA_snn_res.")


emb.GFPpooled_v2.filteredClustersFINAL <- FindClusters(emb.GFPpooled_v2.filteredClustersFINAL, resolution = 1.2, cluster.name = "filtered_clusters_FINAL")

emb.GFPpooled_v2.filteredClustersFINAL <- RunUMAP(emb.GFPpooled_v2.filteredClustersFINAL, dims = 1:5, reduction = "pca", reduction.name = "umap.filtered.final")

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.UMAP.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", label = TRUE, label.size = 7, pt.size = 1)
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.UMAP-rep.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", split.by = "rep_group")
dev.off()
```


```{r}
#check clusters for expression of intestine marker genes
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)

VlnPlot(object = emb.GFPpooled_v2.filteredClustersFINAL, features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"))

#check clusters for expression of all tissue marker genes

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.FeaturePlot.AllTissueMarkerGenes.pdf", height = 20, width = 24)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("elt-2", "elt-7", "ges-1", "glh-1", "nos-1", "pgl-1", "rab-3", "odr-2",  "mec-7", "myo-3", "pat-10", "lev-11", "myo-2", "tnc-2", "phat-2", "elt-1", "elt-3", "dpy-7"), ncol = 3, coord.fixed = TRUE)
dev.off()
```


```{r}
# find new cluster marker genes in our filtered dataset

emb.GFPpooled_v2.filteredClustersFINAL.markers <- FindAllMarkers(emb.GFPpooled_v2.filteredClustersFINAL, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

write.csv(emb.GFPpooled_v2.filteredClustersFINAL.markers,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL_markers.csv", row.names = TRUE)

emb.GFPpooled_v2.filteredClustersFINAL.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% slice_max(n = 3, order_by = avg_log2FC) 
```

```{r}
# The UMAP embedding are stored in the Seurat object under the reductions slot. Extract the number of cells by checking the number of rows in the UMAP embedding matrix. Counting the number of rows in this matrix, directly corresponds to the number of cells that have UMAP embedding.

num_int_cells <- nrow(Embeddings(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final"))
print(paste("Number of intestinal cells in UMAP:", num_int_cells))

num_all_cells <- nrow(Embeddings(emb.ALLpooled_v2, reduction = "umap.unintegrated"))
print(paste("Number of all cells in UMAP:", num_all_cells))
```


```{r}
# make some pretty heatmaps 

emb.GFPpooled_v2.filteredClustersFINAL.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=3, wt=avg_log2FC) -> top3

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.HeatMap-top3.pdf", height = 10, width = 15)
DoHeatmap(emb.GFPpooled_v2.filteredClustersFINAL, features = c(top3$gene), raster=F) + 
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()


emb.GFPpooled_v2.filteredClustersFINAL.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.HeatMap-top10.pdf", height = 20, width = 15)
DoHeatmap(emb.GFPpooled_v2.filteredClustersFINAL, features = c(top10$gene), raster=F) + 
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()



# With smiFISH targets in the heatmap as well (will be on the bottom)

emb.GFPpooled_v2.filteredClustersFINAL.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=2, wt=avg_log2FC) -> top2

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.HeatMap-top2.smifish.pdf", height = 10, width = 15)
DoHeatmap(emb.GFPpooled_v2.filteredClustersFINAL, features = c(top2$gene, "clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F) +
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.HeatMap-smiFISH.pdf", height = 8, width = 10)
DoHeatmap(emb.GFPpooled_v2.filteredClustersFINAL, features = c("clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F) + 
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()
```


```{r}
# RNAi/FISH targets
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.rnai-FISH.pdf", height = 6, width = 15)  
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("C14C6.5", "cpr-1", "Y32F6A.5", "endu-2", "clec-56", "pbo-4", "ugt-14"), ncol = 3, coord.fixed = TRUE)
dev.off()

VlnPlot(emb.GFPpooled_v2.filteredClustersFINAL, features = c("C14C6.5", "cpr-1", "Y32F6A.5", "endu-2", "clec-56", "pbo-4", "ugt-14"), raster=F, ncol = 3)

# intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.intestine.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("elt-2", "elt-7", "ges-1"), ncol = 3, coord.fixed = TRUE)
dev.off() 

VlnPlot(object = emb.GFPpooled_v2.filteredClustersFINAL, features = c("elt-2", "elt-7", "ges-1"), ncol = 2)

# germline
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.germ.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("glh-1", "nos-1", "pgl-1"), ncol = 3, coord.fixed = TRUE)
dev.off()

VlnPlot(object = emb.GFPpooled_v2.filteredClustersFINAL, features = c("glh-1", "nos-1", "pgl-1"), ncol = 2)

# muscle
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.muscle.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("myo-3", "pat-10", "lev-11"), ncol = 3, coord.fixed = TRUE)
dev.off()

VlnPlot(object = emb.GFPpooled_v2.filteredClustersFINAL, features = c("myo-3", "pat-10", "lev-11"), ncol = 2)

# neuron
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.neuron.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("rab-3", "odr-2", "mec-7"), ncol = 3, coord.fixed = TRUE)
dev.off()

VlnPlot(object = emb.GFPpooled_v2.filteredClustersFINAL, features = c("rab-3", "odr-2", "mec-7"), ncol = 2)

# pharynx
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.pharynx.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("myo-2", "tnc-2", "phat-2"), ncol = 3, coord.fixed = TRUE)
dev.off()

VlnPlot(object = emb.GFPpooled_v2.filteredClustersFINAL, features = c("myo-2", "tnc-2", "phat-2"), ncol = 2)

# hypodermis
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.hypodermis.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("elt-1", "elt-3", "dpy-7"), ncol = 3, coord.fixed = TRUE)
dev.off()

VlnPlot(object = emb.GFPpooled_v2.filteredClustersFINAL, features = c("elt-1", "elt-3", "dpy-7"), ncol = 2)

# early intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.earlyint.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("end-1", "acp-2", "ugt-14", "C10C5.4"), ncol = 2 , coord.fixed = TRUE)
dev.off()

# mid intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.midint.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("T19D7.6", "T21E8.4", "C10A4.3", "klo-1"), ncol = 2 , coord.fixed = TRUE) #(not the best) "T20D4.19", "F47B8.4"
dev.off()

# late intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.lateint.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("C14C6.5", "clec-56", "cpr-1", "lec-9"), ncol = 2 , coord.fixed = TRUE)
dev.off()

# anterior intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.anterior-int.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("C14C6.5", "cpr-1"), ncol = 2 , coord.fixed = TRUE)
dev.off()

# central intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.central-int.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("clec-56", "endu-2"), ncol = 2 , coord.fixed = TRUE)
dev.off()

# posterior intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.featureplot.posterior-int.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.filteredClustersFINAL, reduction = "umap.filtered.final", features = c("pbo-4"), ncol = 2 , coord.fixed = TRUE)
dev.off()
```


```{r}
# how many cells are expressing these markers of other tissues in our intestine specific cell population?

total_cells_expressing_gene <- sum(emb.GFPpooled_v2.filteredClustersFINAL@assays$RNA$data["hlh-2", ] > 0) 
print(total_cells_expressing_gene) #24

total_cells_expressing_gene <- sum(emb.GFPpooled_v2.filteredClustersFINAL@assays$RNA$data["myo-3", ] > 0) 
print(total_cells_expressing_gene) #13

total_cells_expressing_gene <- sum(emb.GFPpooled_v2.filteredClustersFINAL@assays$RNA$data["rab-3", ] > 0) 
print(total_cells_expressing_gene) #144
```


```{r}
# how many intestinal cells were in our all cells pooled sample?
# Will count all cells that express at least one of these intestinal marker genes
unique_cells <- colSums(emb.ALLpooled_v2@assays$RNA$data[c("elt-2", "elt-7", "ges-1"), ] > 0) > 0
sum(unique_cells) # 1389

total_cells <- ncol(emb.ALLpooled_v2@assays$RNA$data)
print(total_cells) #18738

a <- (1389/18738)*100
print(a) #7.4%
```


```{r}
# GO analysis version 1

#  install packages
BiocManager::install("Rsamtools")
install.packages("Signac")
install.packages("cowplot")
BiocManager::install("org.Ce.eg.db")
BiocManager::install("biovizBase")
BiocManager::install("clusterProfiler")
BiocManager::install("enrichplot")
BiocManager::install("ggtree")

# load libraries
library(Signac)
library(cowplot)
library(clusterProfiler)
library(org.Ce.eg.db)
library(enrichplot)
library(ggtree)

#If you use [clusterProfiler](https://www.bioconductor.org/packages/clusterProfiler) in published research, please cite:

#__*G Yu*__, LG Wang, Y Han, QY He. clusterProfiler: an R package for comparing biological themes among gene clusters. **_OMICS: A Journal of Integrative Biology_** 2012, 16(5):284-287. doi:[10.1089/omi.2011.0118](http://dx.doi.org/10.1089/omi.2011.0118)

# https://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html
```


```{r}
Cluster0.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==0 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster1.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==1 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster2.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==2 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster3.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==3 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster4.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==4 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster5.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==5 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster6.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==6 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster7.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==7 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster8.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==8 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster9.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==9 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster10.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==10 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster11.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==11 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster12.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==12 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster13.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==13 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
Cluster14.markers <- emb.GFPpooled_v2.filteredClustersFINAL.markers[emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster==14 & emb.GFPpooled_v2.filteredClustersFINAL.markers$p_val_adj < 0.05, ]
```


```{r}
Cluster0.gene_ids <- bitr(Cluster0.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.09% of input gene IDs are fail to map...
Cluster1.gene_ids <- bitr(Cluster1.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #1.8% of input gene IDs are fail to map...
Cluster2.gene_ids <- bitr(Cluster2.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #0.33% of input gene IDs are fail to map...
Cluster3.gene_ids <- bitr(Cluster3.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.01% of input gene IDs are fail to map...
Cluster4.gene_ids <- bitr(Cluster4.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.49% of input gene IDs are fail to map...
Cluster5.gene_ids <- bitr(Cluster5.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.21% of input gene IDs are fail to map...
Cluster6.gene_ids <- bitr(Cluster6.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #1.6% of input gene IDs are fail to map...
Cluster7.gene_ids <- bitr(Cluster7.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #1.85% of input gene IDs are fail to map...
Cluster8.gene_ids <- bitr(Cluster8.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.74% of input gene IDs are fail to map...
Cluster9.gene_ids <- bitr(Cluster9.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #1.79% of input gene IDs are fail to map...
Cluster10.gene_ids <- bitr(Cluster10.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.62% of input gene IDs are fail to map...
Cluster11.gene_ids <- bitr(Cluster11.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #4.07% of input gene IDs are fail to map...
Cluster12.gene_ids <- bitr(Cluster12.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #1.81% of input gene IDs are fail to map...
Cluster13.gene_ids <- bitr(Cluster13.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #0.89% of input gene IDs are fail to map...
Cluster14.gene_ids <- bitr(Cluster14.markers$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db) #1.65% of input gene IDs are fail to map...
```


```{r}
# how to do for one individual cluster

Cluster0.ego <- enrichGO(gene = Cluster0.gene_ids$ENTREZID, 
                OrgDb = org.Ce.eg.db, 
                ont = "BP", # biological process
                pAdjustMethod = "BH", 
                pvalueCutoff = 0.05, 
                qvalueCutoff = 0.05, 
                readable = TRUE)
```
```{r}
barplot(Cluster0.ego, showCategory=10, title="GO Enrichment Analysis for Cluster 0")
```
```{r}
p1 <- dotplot(Cluster0.ego, showCategory=20, title="GO Enrichment Analysis for Cluster 0")
p1 + theme(axis.text.y = element_text(size = 3))
```
```{r}
Cluster0.ego <- pairwise_termsim(Cluster0.ego)
emapplot(Cluster0.ego, showCategory=20)
```
```{r}
#install.packages("ggupset")
#library(ggupset)

upsetplot(Cluster0.ego)
```


```{r}
# how to do for all clusters 

cluster_gene_list <- split(emb.GFPpooled_v2.filteredClustersFINAL.markers$gene, emb.GFPpooled_v2.filteredClustersFINAL.markers$cluster)

cluster_gene_list <- lapply(cluster_gene_list, function(genes) {
  gene_ids <- bitr(genes, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db)
  return(gene_ids$ENTREZID)
})

# Use the compareCluster() function from clusterProfiler package to perform gene ontology analysis for all clusters together.

# GO enrichment analysis for BP
go_compare_bp <- compareCluster(geneCluster = cluster_gene_list, 
                             fun = "enrichGO", 
                             OrgDb = org.Ce.eg.db, 
                             ont = "BP",  #("BP"、"MF" or "CC")
                             pAdjustMethod = "BH",
                             pvalueCutoff = 0.05,
                             qvalueCutoff = 0.05)

bp <- clusterProfiler::simplify(go_compare_bp, cutoff = 0.7, by="p.adjust", select_fun = min)

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.dotPlot-GO-BP.pdf", height = 10, width = 20)
cluster.p1 <- dotplot(bp, showCategory = 1,
              title = "GO Enrichment (Biological Process)")
cluster.p1 + theme(
  axis.text.y = element_text(size = 15),
  axis.text.x = element_text(size = 15),
  legend.text = element_text(size = 15)
  )
dev.off()



#Dot plots are not good for showing the relationship between GO terms. Can select and cluster GO terms first, and then use a tree plot to show the correlations between GO terms.
trim_bp <- pairwise_termsim(bp, method = "JC")

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.treeMap-GO-BP.pdf", height = 20, width = 30)
treeplot(trim_bp, showCategory = 3, cladelab_offset=5, tiplab_offset=.3, fontsize_cladelab =6, fontsize_tiplab =5, hexpand(.2), legend_n = 3,  nCluster = 5)  
dev.off()
```


```{r}
# how to do for specific clusters - across developmental time

#early intestine
VlnPlot(emb.GFPpooled_v2.filteredClustersFINAL, features = c('end-1', 'acp-2', 'ugt-14', 'C10C5.4'), raster=F, ncol = 2)

#mid intestine
VlnPlot(emb.GFPpooled_v2.filteredClustersFINAL, features = c('T19D7.6', 'T21E8.4', 'klo-1', 'C10A4.3'), raster=F, ncol = 2)

#late intestine
VlnPlot(emb.GFPpooled_v2.filteredClustersFINAL, features = c('C14C6.5', 'clec-56', 'cpr-1', 'lec-9'), raster=F, ncol = 2)


early_clusters <- as.character(c(14))
mid_clusters <- as.character(c(1, 2, 3, 6, 7, 14))
late_clusters <- as.character(c(4, 5, 7, 8, 12, 2, 9, 11, 13))

background_gene_list <- cluster_gene_list

early_clusters.list <- cluster_gene_list[names(cluster_gene_list) %in% early_clusters]
mid_clusters.list <- cluster_gene_list[names(cluster_gene_list) %in% mid_clusters]
late_clusters.list <- cluster_gene_list[names(cluster_gene_list) %in% late_clusters]

go_compare_bp_early <- compareCluster(geneCluster = early_clusters.list, 
                             fun = "enrichGO", 
                             OrgDb = org.Ce.eg.db, 
                             ont = "BP",
                             universe = background_gene_list,
                             pAdjustMethod = "BH",
                             pvalueCutoff = 0.05,
                             qvalueCutoff = 0.05)

go_compare_bp_mid <- compareCluster(geneCluster = mid_clusters.list, 
                             fun = "enrichGO", 
                             OrgDb = org.Ce.eg.db, 
                             ont = "BP",
                             universe = background_gene_list,
                             pAdjustMethod = "BH",
                             pvalueCutoff = 0.05,
                             qvalueCutoff = 0.05)

go_compare_bp_late <- compareCluster(geneCluster = late_clusters.list, 
                             fun = "enrichGO", 
                             OrgDb = org.Ce.eg.db, 
                             ont = "BP",
                             universe = background_gene_list,
                             pAdjustMethod = "BH",
                             pvalueCutoff = 0.05,
                             qvalueCutoff = 0.05)


bp_early_dev <- clusterProfiler::simplify(go_compare_bp_early, cutoff=0.7, by="p.adjust", select_fun=min)
bp_mid_dev <- clusterProfiler::simplify(go_compare_bp_mid, cutoff=0.7, by="p.adjust", select_fun=min)
bp_late_dev <- clusterProfiler::simplify(go_compare_bp_late, cutoff=0.7, by="p.adjust", select_fun=min)



pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.dotPlot-GO-BP_early_dev-background.pdf", height = 10, width = 20)
cluster.p1 <- dotplot(bp_early_dev, showCategory = 1,
              title = "GO Enrichment (Biological Process)")
cluster.p1 + theme(
  axis.text.y = element_text(size = 15),
  axis.text.x = element_text(size = 15),
  legend.text = element_text(size = 15)
  )
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.dotPlot-GO-BP_mid_dev-background.pdf", height = 10, width = 20)
cluster.p1 <- dotplot(bp_mid_dev, showCategory = 1,
              title = "GO Enrichment (Biological Process)")
cluster.p1 + theme(
  axis.text.y = element_text(size = 15),
  axis.text.x = element_text(size = 15),
  legend.text = element_text(size = 15)
  )
dev.off()



pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.dotPlot-GO-BP_late_dev-background.pdf", height = 10, width = 20)
cluster.p1 <- dotplot(bp_late_dev, showCategory = 1,
              title = "GO Enrichment (Biological Process)")
cluster.p1 + theme(
  axis.text.y = element_text(size = 15),
  axis.text.x = element_text(size = 15),
  legend.text = element_text(size = 15)
  )
dev.off()
```


```{r}
#anterior intestine
VlnPlot(emb.GFPpooled_v2.filteredClustersFINAL, features = c('C14C6.5', 'cpr-1'), raster=F, ncol = 2)

#central intestine
VlnPlot(emb.GFPpooled_v2.filteredClustersFINAL, features = c('endu-2', 'clec-56'), raster=F, ncol = 2)

#posterior
VlnPlot(emb.GFPpooled_v2.filteredClustersFINAL, features = c('pbo-4'), raster=F, ncol = 2)



anterior_clusters <- as.character(c(4,7,8,12))
central_clusters <- as.character(c(2,4,5,7,8,9))
posterior_clusters <- as.character(c(2,5,9,11,14))

background_gene_list <- cluster_gene_list

anterior_clusters.list <- cluster_gene_list[names(cluster_gene_list) %in% anterior_clusters]
central_clusters.list <- cluster_gene_list[names(cluster_gene_list) %in% central_clusters]
posterior_clusters.list <- cluster_gene_list[names(cluster_gene_list) %in% posterior_clusters]

go_compare_bp_ant <- compareCluster(geneCluster = anterior_clusters.list, 
                             fun = "enrichGO", 
                             OrgDb = org.Ce.eg.db, 
                             ont = "BP",
                             universe = background_gene_list,
                             pAdjustMethod = "BH",
                             pvalueCutoff = 0.05,
                             qvalueCutoff = 0.05)

go_compare_bp_cen <- compareCluster(geneCluster = central_clusters.list, 
                             fun = "enrichGO", 
                             OrgDb = org.Ce.eg.db, 
                             ont = "BP",
                             universe = background_gene_list,
                             pAdjustMethod = "BH",
                             pvalueCutoff = 0.05,
                             qvalueCutoff = 0.05)

go_compare_bp_post <- compareCluster(geneCluster = posterior_clusters.list, 
                             fun = "enrichGO", 
                             OrgDb = org.Ce.eg.db, 
                             ont = "BP",
                             universe = background_gene_list,
                             pAdjustMethod = "BH",
                             pvalueCutoff = 0.05,
                             qvalueCutoff = 0.05)


bp_ant_dev <- clusterProfiler::simplify(go_compare_bp_ant, cutoff=0.7, by="p.adjust", select_fun=min)
bp_cen_dev <- clusterProfiler::simplify(go_compare_bp_cen, cutoff=0.7, by="p.adjust", select_fun=min)
bp_post_dev <- clusterProfiler::simplify(go_compare_bp_post, cutoff=0.7, by="p.adjust", select_fun=min)



pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.dotPlot-GO-BP_anterior-background.pdf", height = 10, width = 20)
cluster.p1 <- dotplot(bp_ant_dev, showCategory = 1,
              title = "GO Enrichment (Biological Process)")
cluster.p1 + theme(
  axis.text.y = element_text(size = 15),
  axis.text.x = element_text(size = 15),
  legend.text = element_text(size = 15)
  )
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.dotPlot-GO-BP_central-background.pdf", height = 10, width = 20)
cluster.p1 <- dotplot(bp_cen_dev, showCategory = 1,
              title = "GO Enrichment (Biological Process)")
cluster.p1 + theme(
  axis.text.y = element_text(size = 15),
  axis.text.x = element_text(size = 15),
  legend.text = element_text(size = 15)
  )
dev.off()



pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClustersFINAL.dotPlot-GO-BP_posterior-background.pdf", height = 10, width = 20)
cluster.p1 <- dotplot(bp_post_dev, showCategory = 1,
              title = "GO Enrichment (Biological Process)")
cluster.p1 + theme(
  axis.text.y = element_text(size = 15),
  axis.text.x = element_text(size = 15),
  legend.text = element_text(size = 15)
  )
dev.off()
```


```{r}
# Calculate gene level variance in expression across clusters: for a given gene, how different is its typical expression between clusters?

# Average expression per cluster. Rows = genes, Columns = clusters. Removes cluster size as a confound, so when compute variance across clusters you’re measuring biological differences in expression, not how many cells happened to be in each cluster.
avg_expr <- AverageExpression(emb.GFPpooled_v2.filteredClusters, return.seurat = FALSE)$RNA

# variance of each gene across clusters: apply(X, MARGIN, FUNction)
gene_variances <- apply(avg_expr, 1, var)

# select top variable genes (e.g., top 50)
#top_genes <- names(sort(gene_variances, decreasing = TRUE))[1:500]
#top_genes <- names(sort(gene_variances, decreasing = TRUE))[1:50]

threshold <- 0.1

top_genes <- names(gene_variances[gene_variances > threshold])
top_genes <- top_genes[order(gene_variances[top_genes], decreasing = TRUE)]

# extract the expression values for top genes
heatmap_data <- avg_expr[top_genes, ]
num_genes <- nrow(heatmap_data)
print(num_genes)

# scale genes (z-score across clusters)
scaled_data <- t(scale(t(as.matrix(heatmap_data))))

# plot heatmap
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.filteredClusters.varianceHM.pdf", height = 10, width = 20)
pheatmap(scaled_data,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         show_rownames = TRUE,
         show_colnames = TRUE,
         fontsize_row = 8,
         main = "Top Variable Genes Across Clusters")
dev.off()
```


```{r}
# genes and cells in each counts matrix
dim(emb.GFPpooled_v2) #15116  2571
dim(emb.GFPpooled_v2.filteredClusters) #15116   2414

dim(emb.ALLpooled_v2) #18590 18738
```


```{r}
# Diagnostic plots for the integration techniques

# Visualize cell embeddings (the principle components, the dimensionality)
head(emb.GFPpooled_v2@reductions$pca@cell.embeddings)
view(emb.GFPpooled_v2@reductions$pca@cell.embeddings)

metadata_pca <- as.data.frame(emb.GFPpooled_v2@reductions$pca@cell.embeddings)
metadata_pca <- rownames_to_column(metadata_pca)
metadata_pca$rep_group <- ""
metadata_pca$rep_group <- dplyr::case_when(
  grepl("-1$", metadata_pca$rowname) ~ "Rep_1",
  grepl("-2$", metadata_pca$rowname) ~ "Rep_2",
  grepl("-3$", metadata_pca$rowname) ~ "Rep_3",
  grepl("-4$", metadata_pca$rowname) ~ "Rep_4",
  TRUE ~ "Unknown"
)

view(metadata_pca)

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.pca_embeddings.pdf", height = 10, width = 20)
p <- ggplot(metadata_pca[sample(nrow(metadata_pca)),]) 
#p1 <- p + geom_point(aes(PC_1, PC_2, color = rep_group, size = rep_group))
p1 <- p + geom_point(aes(PC_1, PC_2, color = rep_group))
#p2 <- p + geom_point(aes(PC_3, PC_4, color = rep_group, size = rep_group))
p2 <- p + geom_point(aes(PC_3, PC_4, color = rep_group))
#p3 <- p + geom_point(aes(PC_5, PC_6, color = rep_group, size = rep_group))
p3 <- p + geom_point(aes(PC_5, PC_6, color = rep_group))
#p4 <- p + geom_point(aes(PC_7, PC_8, color = rep_group, size = rep_group))
p4 <- p + geom_point(aes(PC_7, PC_8, color = rep_group))
p1 + p2 + p3 + p4 + plot_layout(ncol = 4)
dev.off()



head(emb.GFPpooled_v2@reductions$integrated.harmony@cell.embeddings)
view(emb.GFPpooled_v2@reductions$integrated.harmony@cell.embeddings)

metadata_har <- as.data.frame(emb.GFPpooled_v2@reductions$integrated.harmony@cell.embeddings)
metadata_har <- rownames_to_column(metadata_har)
metadata_har$rep_group <- ""
metadata_har$rep_group <- dplyr::case_when(
  grepl("-1$", metadata_har$rowname) ~ "Rep_1",
  grepl("-2$", metadata_har$rowname) ~ "Rep_2",
  grepl("-3$", metadata_har$rowname) ~ "Rep_3",
  grepl("-4$", metadata_har$rowname) ~ "Rep_4",
  TRUE ~ "Unknown"
)

view(metadata_har)

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.harmony_embeddings.pdf", height = 10, width = 20)
p <- ggplot(metadata_har[sample(nrow(metadata_har)),]) 
p1 <- p + geom_point(aes(harmony_1, harmony_2, color = rep_group))
p2 <- p + geom_point(aes(harmony_3, harmony_4, color = rep_group))
p3 <- p + geom_point(aes(harmony_5, harmony_6, color = rep_group))
p4 <- p + geom_point(aes(harmony_7, harmony_8, color = rep_group))
p1 + p2 + p3 + p4 + plot_layout(ncol = 4)
dev.off()



head(emb.GFPpooled_v2@reductions$integrated.cca@cell.embeddings)
view(emb.GFPpooled_v2@reductions$integrated.cca@cell.embeddings)

metadata_cca <- as.data.frame(emb.GFPpooled_v2@reductions$integrated.cca@cell.embeddings)
metadata_cca <- rownames_to_column(metadata_cca)
metadata_cca$rep_group <- ""
metadata_cca$rep_group <- dplyr::case_when(
  grepl("-1$", metadata_cca$rowname) ~ "Rep_1",
  grepl("-2$", metadata_cca$rowname) ~ "Rep_2",
  grepl("-3$", metadata_cca$rowname) ~ "Rep_3",
  grepl("-4$", metadata_cca$rowname) ~ "Rep_4",
  TRUE ~ "Unknown"
)

view(metadata_cca)

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.cca_embeddings.pdf", height = 10, width = 20)
p <- ggplot(metadata_cca[sample(nrow(metadata_cca)),]) 
p1 <- p + geom_point(aes(integratedcca_1, integratedcca_2, color = rep_group))
p2 <- p + geom_point(aes(integratedcca_3, integratedcca_4, color = rep_group))
p3 <- p + geom_point(aes(integratedcca_5, integratedcca_6, color = rep_group))
p4 <- p + geom_point(aes(integratedcca_7, integratedcca_8, color = rep_group))
p1 + p2 + p3 + p4 + plot_layout(ncol = 4)
dev.off()
```


```{r}
metadata_har_long <- metadata_har %>%
  pivot_longer(
    cols = starts_with("harmony_"),  # or use harmony_1:harmony_3 to be specific
    names_to = "Harmony_PC",
    values_to = "Embedding_Value"
  )
 
# Plot density distributions of Harmony components grouped by rep
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.harmony_embeddings_hist.pdf", height = 10, width = 20)
ggplot(metadata_har_long, aes(x = Embedding_Value, color = rep_group, fill = rep_group)) + 
  geom_density(alpha = 0.3) +
  facet_wrap(~ Harmony_PC, scales = "free") +
  theme_minimal() +
  labs(
    title = "Density of Harmony components by replicate group",
    x = "Embedding Value",
    y = "Density"
  )
dev.off()




metadata_pca_long <- metadata_pca %>%
  pivot_longer(
    cols = starts_with("PC_"),
    names_to = "PCA_PC",
    values_to = "Embedding_Value"
  )
 
# Plot density distributions of Harmony components grouped by rep
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.pca_embeddings_hist.pdf", height = 10, width = 20)
ggplot(metadata_pca_long, aes(x = Embedding_Value, color = rep_group, fill = rep_group)) + 
  geom_density(alpha = 0.3) +
  facet_wrap(~ PCA_PC, scales = "free") +
  theme_minimal() +
  labs(
    title = "Density of unintegrated PC components by replicate group",
    x = "Embedding Value",
    y = "Density"
  )
dev.off()



metadata_cca_long <- metadata_cca %>%
  pivot_longer(
    cols = starts_with("integratedcca_"),
    names_to = "CCA_PC",
    values_to = "Embedding_Value"
  )
 
# Plot density distributions of Harmony components grouped by rep
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.cca_embeddings_hist.pdf", height = 10, width = 20)
ggplot(metadata_cca_long, aes(x = Embedding_Value, color = rep_group, fill = rep_group)) + 
  geom_density(alpha = 0.3) +
  facet_wrap(~ CCA_PC, scales = "free") +
  theme_minimal() +
  labs(
    title = "Density of CCA components by replicate group",
    x = "Embedding Value",
    y = "Density"
  )
dev.off()
```


```{r}
metadata_pca_all <- as.data.frame(emb.ALLpooled_v2@reductions$pca@cell.embeddings)
metadata_pca_all <- rownames_to_column(metadata_pca_all)
metadata_pca_all$rep_group <- ""
metadata_pca_all$rep_group <- dplyr::case_when(
  grepl("-(1|5)$", metadata_pca_all$rowname) ~ "Rep_1",
  grepl("-(2|6)$", metadata_pca_all$rowname) ~ "Rep_2",
  grepl("-(3|7)$", metadata_pca_all$rowname) ~ "Rep_3",
  grepl("-(4|8)$", metadata_pca_all$rowname) ~ "Rep_4",
  TRUE ~ "Unknown"
)

view(metadata_pca_all)

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.pca_embeddings.pdf", height = 10, width = 20)
p <- ggplot(metadata_pca_all[sample(nrow(metadata_pca_all)),]) 
#p1 <- p + geom_point(aes(PC_1, PC_2, color = rep_group, size = rep_group))
p1 <- p + geom_point(aes(PC_1, PC_2, color = rep_group))
#p2 <- p + geom_point(aes(PC_3, PC_4, color = rep_group, size = rep_group))
p2 <- p + geom_point(aes(PC_3, PC_4, color = rep_group))
#p3 <- p + geom_point(aes(PC_5, PC_6, color = rep_group, size = rep_group))
p3 <- p + geom_point(aes(PC_5, PC_6, color = rep_group))
#p4 <- p + geom_point(aes(PC_7, PC_8, color = rep_group, size = rep_group))
p4 <- p + geom_point(aes(PC_7, PC_8, color = rep_group))
p1 + p2 + p3 + p4 + plot_layout(ncol = 4)
dev.off()






metadata_cca_all <- as.data.frame(emb.ALLpooled_v2@reductions$integrated.cca@cell.embeddings)
metadata_cca_all <- rownames_to_column(metadata_cca_all)
metadata_cca_all$rep_group <- ""
metadata_cca_all$rep_group <- dplyr::case_when(
  grepl("-(1|5)$", metadata_cca_all$rowname) ~ "Rep_1",
  grepl("-(2|6)$", metadata_cca_all$rowname) ~ "Rep_2",
  grepl("-(3|7)$", metadata_cca_all$rowname) ~ "Rep_3",
  grepl("-(4|8)$", metadata_cca_all$rowname) ~ "Rep_4",
  TRUE ~ "Unknown"
)

view(metadata_cca_all)

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.cca_embeddings.pdf", height = 10, width = 20)
p <- ggplot(metadata_cca_all[sample(nrow(metadata_cca_all)),]) 
p1 <- p + geom_point(aes(integratedcca_1, integratedcca_2, color = rep_group))
p2 <- p + geom_point(aes(integratedcca_3, integratedcca_4, color = rep_group))
p3 <- p + geom_point(aes(integratedcca_5, integratedcca_6, color = rep_group))
p4 <- p + geom_point(aes(integratedcca_7, integratedcca_8, color = rep_group))
p1 + p2 + p3 + p4 + plot_layout(ncol = 4)
dev.off()
```


```{r}
metadata_pca_long_all <- metadata_pca_all %>%
  pivot_longer(
    cols = starts_with("PC_"),
    names_to = "PCA_PC",
    values_to = "Embedding_Value"
  )
 
# Plot density distributions of Harmony components grouped by rep
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.pca_embeddings_hist.pdf", height = 10, width = 20)
ggplot(metadata_pca_long_all, aes(x = Embedding_Value, color = rep_group, fill = rep_group)) + 
  geom_density(alpha = 0.3) +
  facet_wrap(~ PCA_PC, scales = "free") +
  theme_minimal() +
  labs(
    title = "Density of unintegrated PC components by replicate group",
    x = "Embedding Value",
    y = "Density"
  )
dev.off()



metadata_cca_long_all <- metadata_cca_all %>%
  pivot_longer(
    cols = starts_with("integratedcca_"),
    names_to = "CCA_PC",
    values_to = "Embedding_Value"
  )
 
# Plot density distributions of Harmony components grouped by rep
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.cca_embeddings_hist.pdf", height = 10, width = 20)
ggplot(metadata_cca_long_all, aes(x = Embedding_Value, color = rep_group, fill = rep_group)) + 
  geom_density(alpha = 0.3) +
  facet_wrap(~ CCA_PC, scales = "free") +
  theme_minimal() +
  labs(
    title = "Density of CCA components by replicate group",
    x = "Embedding Value",
    y = "Density"
  )
dev.off()
```


```{r}
sessionInfo() 
```
----















# Perform gene ontology
```{r}
library(reticulate)
py_config()
# to modify the python to use in R, nano ~/.Renviron. just uncomment the right path and comment out the other. Will need to restart the Rsession before implimenting. 
use_condaenv("base")

tea <- import("tissue_enrichment_analysis")
tissue_df <- tea$fetch_dictionary("tissue")
phenotype_df <- tea$fetch_dictionary("phenotype")
go_df <- tea$fetch_dictionary("go")
```

```{r}
emb.GFPpooled_v2.clean.markers_1 <- emb.GFPpooled_v2.clean.markers %>% left_join(genes.df, by = c("gene" = "external_gene_id")) 
view(emb.GFPpooled_v2.clean.markers_1)


emb.GFPpooled_v2.clean.markers_1 <- emb.GFPpooled_v2.clean.markers_1 %>% rename(WBGeneID = wbps_gene_id)
#emb.GFPpooled_v2.clean.markers_1 <- emb.GFPpooled_v2.clean.markers_1 %>% rename(wbid = WBGeneID)
view(emb.GFPpooled_v2.clean.markers_1)


emb.ALLpooled_v2.markers_1 <- emb.ALLpooled_v2.markers %>% left_join(genes.df, by = c("gene" = "external_gene_id")) 
view(emb.ALLpooled_v2.markers_1)


emb.ALLpooled_v2.markers_1 <- emb.ALLpooled_v2.markers_1 %>% rename(WBGeneID = wbps_gene_id)
#emb.ALLpooled_v2.markers_1 <- emb.ALLpooled_v2.markers_1 %>% rename(wbid = WBGeneID)
view(emb.ALLpooled_v2.markers_1)
```

```{r}
# set up go_df to represent only our background genes 
view(go_df)

cluster0 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 0)
view(cluster0)
cluster1 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 1)
view(cluster1)
cluster2 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 2)
view(cluster2)
cluster3 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 3)
view(cluster3)
cluster4 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 4)
view(cluster4)
cluster5 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 5)
view(cluster5)
cluster6 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 6)
view(cluster6)
cluster7 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 7)
view(cluster7)
cluster8 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 8)
view(cluster8)
cluster9 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 9)
view(cluster9)
cluster10 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 10)
view(cluster10)
cluster11 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 11)
view(cluster11)
cluster12 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 12)
view(cluster12)
cluster13 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 13)
view(cluster13)



go_df_background <- go_df %>% filter(wbid %in% emb.GFPpooled_v2.clean.markers_1$WBGeneID)
view(go_df_background)

go_df_background_0 <- go_df %>% filter(wbid %in% cluster0$WBGeneID)
view(go_df_background_0)
go_df_background_1 <- go_df %>% filter(wbid %in% cluster1$WBGeneID)
view(go_df_background_1)
go_df_background_2 <- go_df %>% filter(wbid %in% cluster2$WBGeneID)
view(go_df_background_2)
go_df_background_3 <- go_df %>% filter(wbid %in% cluster3$WBGeneID)
view(go_df_background_3)
go_df_background_4 <- go_df %>% filter(wbid %in% cluster4$WBGeneID)
view(go_df_background_4)
go_df_background_5 <- go_df %>% filter(wbid %in% cluster5$WBGeneID)
view(go_df_background_5)
go_df_background_6 <- go_df %>% filter(wbid %in% cluster6$WBGeneID)
view(go_df_background_6)
go_df_background_7 <- go_df %>% filter(wbid %in% cluster7$WBGeneID)
view(go_df_background_7)
go_df_background_8 <- go_df %>% filter(wbid %in% cluster8$WBGeneID)
view(go_df_background_8)
go_df_background_9 <- go_df %>% filter(wbid %in% cluster9$WBGeneID)
view(go_df_background_9)
go_df_background_10 <- go_df %>% filter(wbid %in% cluster10$WBGeneID)
view(go_df_background_10)
go_df_background_11 <- go_df %>% filter(wbid %in% cluster11$WBGeneID)
view(go_df_background_11)
go_df_background_12 <- go_df %>% filter(wbid %in% cluster12$WBGeneID)
view(go_df_background_12)
go_df_background_13 <- go_df %>% filter(wbid %in% cluster13$WBGeneID)
view(go_df_background_13)
```


```{r}
clusters <- emb.GFPpooled_v2.clean.markers_1$cluster

clusters <- cluster0$cluster
clusters <- cluster1$cluster
clusters <- cluster2$cluster
clusters <- cluster3$cluster
clusters <- cluster4$cluster
clusters <- cluster5$cluster
clusters <- cluster6$cluster
clusters <- cluster7$cluster
clusters <- cluster8$cluster
clusters <- cluster9$cluster
clusters <- cluster10$cluster
clusters <- cluster11$cluster
clusters <- cluster12$cluster
clusters <- cluster13$cluster
```
```{r}
my_tea_analysis <- function(input_df, tea_dict){
  tea_df <- data.frame()
  for (i in clusters){
  tea_set <- tea$enrichment_analysis(
    (input_df %>% 
       filter(cluster == i))$WBGeneID, 
    tissue_df = tea_dict 
  )
  if(nrow(tea_set) == 0){
    next
  } else {
  tea_df <- bind_rows(tea_df, data.frame(tea_set, cluster = i))
  }
}
tea_df
}

reorder_within <- function(x, by, within, fun = mean, sep = "___", ...) {
    new_x <- paste(x, within, sep = sep)
    stats::reorder(new_x, by, FUN = fun)
}

scale_x_reordered <- function(..., sep = "___") {
    reg <- paste0(sep, ".+$")
    ggplot2::scale_x_discrete(labels = function(x) gsub(reg, "", x), ...)
}

my_ontology_plot <- function(input_df, xlabel){
  input_df %>%
  filter(Q.value < 0.001,  Observed > 10) %>% 
  ggplot(aes(x = reorder_within(Term, -log10(Q.value), cluster), y = -log10(Q.value))) +
  geom_point(aes(size = Observed)) +
  coord_flip() +
  scale_x_reordered() +
  facet_wrap(cluster~., ncol = 3, scales = "free_y") +
  theme_bw() +
  xlab(xlabel) +
  guides(size = guide_legend(title = "# genes")) +
  scale_size_continuous(breaks = c(10,20,100,200,300))
}
```

```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_0_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster0 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_0), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_0.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster0 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_1_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster1 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_1), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_1.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster1 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
# pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_2_background.pdf", height = 10, width = 20)
# my_ontology_plot(my_tea_analysis(cluster2 %>% filter(p_val_adj < 0.01, avg_log2FC > 0.5), go_df_background_2), "Gene Ontology") + theme(text = element_text(size = 30))
# dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_2.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster2 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_3_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster3 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_3), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_3.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster3 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_4_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster4 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df_background_4), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_4.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster4 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
# pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_5_background.pdf", height = 10, width = 20)
# my_ontology_plot(my_tea_analysis(cluster5 %>% filter(p_val_adj < 0.01, avg_log2FC > 0.5), go_df_background_5), "Gene Ontology") + theme(text = element_text(size = 30))
# dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_5.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster5 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_6_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster6 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_6), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_6.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster6 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_7_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster7 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_7), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_7.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster7 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
# pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_8_background.pdf", height = 10, width = 20)
# my_ontology_plot(my_tea_analysis(cluster8 %>% filter(p_val_adj < 0.01, avg_log2FC > 0.5), go_df_background_8), "Gene Ontology") + theme(text = element_text(size = 30))
# dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_8.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster8 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
# pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_9_background.pdf", height = 10, width = 20)
# my_ontology_plot(my_tea_analysis(cluster9 %>% filter(p_val_adj < 0.05, avg_log2FC > 0.5), go_df_background_9), "Gene Ontology") + theme(text = element_text(size = 30))
# dev.off()
# 
# pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_9.pdf", height = 10, width = 20)
# my_ontology_plot(my_tea_analysis(cluster9 %>% filter(p_val_adj < 0.01, avg_log2FC > 0.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
# dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_10_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster10 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_10), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_10.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster10 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_11_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster11 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_11), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_11.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster11 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_12_background.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(cluster12 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_12), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_12.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(cluster12 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_13_background.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(cluster13 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_13), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_13.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(cluster13 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```

```{r}
# not wide enough output, the figures are smooshed 
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_background.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(emb.GFPpooled_v2.clean.markers_1 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df_background), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(emb.GFPpooled_v2.clean.markers_1 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```














# plot genes of interest
From John Murray dataset 
    - intestine_anterior: ZC204.12, cpr-1, ceh-37
    - intestine_middle_and_posterior: irg-7, pal-1, cpr-1, ceh-37
    - intestine_far_posterior: irg-7, faah-1, pbo-4, psa-3
```{r}
# # top marker gene for each cluster
# FeaturePlot(emb.GFPpooled, pt.size = 0.1,
#             features = (emb.GFPpooled.markers %>% group_by(cluster) %>% slice_max(n = 1, order_by = avg_log2FC))$gene)
```

```{r}
# # genes from murray data
# # intestine_anterior
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('ZC204.12', 'cpr-1', 'ceh-37'), raster=F, ncol = 1) +
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.Murray-Anterior.png") 
# 
# # intestine_middle_and_posterior
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('irg-7', 'pal-1', 'cpr-1', 'ceh-37'), raster=F, ncol = 1) + 
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.Murray-Mid.png")
# 
# # intestine_far_posterior
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('faah-1', 'pbo-4', 'psa-3'), raster=F, ncol = 1) + 
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.Murray-Posterior.png")
```

```{r}
# # marker genes we FISHed for
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('C14C6.5', 'clec-56', 'pbo-4'), raster=F, ncol = 1) + 
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.smiFISH-genes.png")
```

-------------------------------NOT USING RIGHT NOW-----------------------
# Remove contamination clusters
contamination clusters = 6, 12, 20
```{r}
emb.GFPpooled_v2.specificClusters <- RunUMAP(subset(emb.GFPpooled_v2, idents = c('6','12', '20'), invert = TRUE), dims = 1:20)
```
# now rerun PCA and re-lcuster 
```{r}
emb.GFPpooled_v2.specificClusters <- RunPCA(emb.GFPpooled_v2.specificClusters, features = VariableFeatures(object = emb.GFPpooled_v2.specificClusters))

DimPlot(emb.GFPpooled_v2.specificClusters, reduction = "pca")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.DimPlot.png")

ElbowPlot(emb.GFPpooled_v2.specificClusters)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.ElbowPlot.png")
```
```{r}
# Choose the number of PCs to use for re-clustering 
emb.GFPpooled_v2.specificClusters <- FindNeighbors(emb.GFPpooled_v2.specificClusters, dims = 1:7)

# check new clusters with Clustree
emb.GFPpooled_v2.specificClusters.recluster <- FindClusters(
  object = emb.GFPpooled_v2.specificClusters,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:7,
  save.SNN = TRUE)

clustree(emb.GFPpooled_v2.specificClusters.recluster, prefix = "RNA_snn_res.")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.Clustree.png")

emb.GFPpooled_v2.specificClusters.recluster <- FindClusters(emb.GFPpooled_v2.specificClusters, resolution = 1.2)

emb.GFPpooled_v2.specificClusters.recluster <- RunUMAP(emb.GFPpooled_v2.specificClusters.recluster, dims = 1:7)

DimPlot(emb.GFPpooled_v2.specificClusters.recluster, reduction = "umap", group.by = c("rep_group", "seurat_clusters"), pt.size = 1) + theme(legend.text = element_text(size = 15))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.UMAP.png") 

DimPlot(emb.GFPpooled_v2.specificClusters.recluster, reduction = "umap", split.by = c("rep_group"), pt.size = 1) + theme(legend.text = element_text(size = 15))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.UMAP.rep.png") 
```

# Find new marker genes
```{r}
#find markers for every cluster compared to all remaining cells
emb.GFPpooled_v2.specificClusters.recluster.markers <- FindAllMarkers(emb.GFPpooled_v2.specificClusters.recluster, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

emb.GFPpooled_v2.specificClusters.recluster.markers %>% 
  group_by(cluster) %>%
  slice_max(n = 2, order_by = avg_log2FC)

write.csv(emb.GFPpooled_v2.specificClusters.recluster.markers,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.markers.csv", row.names = TRUE)
```


# Validate clusters 
```{r}
emb.GFPpooled_v2.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=1, wt=avg_log2FC) -> top1_reclust

DoHeatmap(emb.GFPpooled_v2.specificClusters.recluster, features = top1_reclust$gene,raster=F) + theme(text = element_text(size = 20))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.HeatMap-top1.png") 

DoHeatmap(emb.GFPpooled_v2.specificClusters.recluster, features = c(top1_reclust$gene, "clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F) + theme(text = element_text(size = 20))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.HeatMap-top1.fish.png") 


# intestine marker genes
FeaturePlot(emb.GFPpooled_v2.specificClusters.recluster, features = c("elt-2","elt-7", 'ges-1'),raster=F, ncol = 2)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.FeaturePlot-PostCtrls.png")

# Contamination marker genes: germline (glh-1, chs-1), muscle (myo-2, myo-3), neuron(hlh-2, rab-3)  
FeaturePlot(emb.GFPpooled_v2.specificClusters.recluster, features = c("glh-1","chs-1", "myo-2", "myo-3", "hlh-2", "rab-3"), raster=F, ncol = 2)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.FeaturePlot-NegCtrls.png")


# FISH
FeaturePlot(emb.GFPpooled_v2.specificClusters.recluster, features = c("clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F, ncol = 3)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.FeaturePlot-FISH.png")
```


# Perform gene ontology
```{r}
library(reticulate)
py_config()
# to modify the python to use in R, nano ~/.Renviron. just uncomment the right path and comment out the other. Will need to restart the Rsession before implimenting. 
use_condaenv("base")

tea <- import("tissue_enrichment_analysis")
tissue_df <- tea$fetch_dictionary("tissue")
phenotype_df <- tea$fetch_dictionary("phenotype")
go_df <- tea$fetch_dictionary("go")
```

```{r}
emb.GFPpooled.specificClusters.recluster.markers <- emb.GFPpooled.specificClusters.recluster.markers %>% left_join(genes.df, by = c("gene" = "external_gene_id")) 

emb.GFPpooled.specificClusters.recluster.markers <- emb.GFPpooled.specificClusters.recluster.markers %>% rename(WBGeneID = wbps_gene_id)
```

```{r}
clusters <- unique(emb.GFPpooled.specificClusters.recluster.markers$cluster)

my_tea_analysis <- function(input_df, tea_dict){
  tea_df <- data.frame()
  for (i in clusters){
  tea_set <- tea$enrichment_analysis(
    (input_df %>% 
       filter(cluster == i))$WBGeneID, 
    tissue_df = tea_dict 
    # %>% 
    #   filter(wbid %in% (input_df %>% 
    #                       filter(cluster %in% clusters))$WBGeneID)
  )
  if(nrow(tea_set) == 0){
    next
  } else {
  tea_df <- bind_rows(tea_df, data.frame(tea_set, cluster = i))
  }
}
tea_df
}

reorder_within <- function(x, by, within, fun = mean, sep = "___", ...) {
    new_x <- paste(x, within, sep = sep)
    stats::reorder(new_x, by, FUN = fun)
}

scale_x_reordered <- function(..., sep = "___") {
    reg <- paste0(sep, ".+$")
    ggplot2::scale_x_discrete(labels = function(x) gsub(reg, "", x), ...)
}

my_ontology_plot <- function(input_df, xlabel){
  input_df %>%
  filter(Q.value < 0.001,  Observed > 50) %>% 
  ggplot(aes(x = reorder_within(Term, -log10(Q.value), cluster), y = -log10(Q.value))) +
  geom_point(aes(size = Observed)) +
  coord_flip() +
  scale_x_reordered() +
  facet_grid(cluster~., scales = "free_y") +
  theme_bw() +
  xlab(xlabel) +
  guides(size = guide_legend(title = "# genes")) +
  scale_size_continuous(breaks = c(20,100,200))
}
```

```{r fig.height=15, fig.width=5}
my_ontology_plot(my_tea_analysis(emb.GFPpooled.specificClusters.recluster.markers %>% filter(p_val_adj < 0.05, avg_log2FC > 1), tissue_df), "Tissue Ontology")

ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.GO_T.png")
```

```{r fig.height=15, fig.width=5}
my_ontology_plot(my_tea_analysis(emb.GFPpooled.specificClusters.recluster.markers %>% filter(p_val_adj < 0.05, avg_log2FC > 1.01), go_df), "Gene Ontology") + theme(text = element_text(size = 15))

ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.GO_G.png")
```


# Pull out new cluster marker genes 
```{r}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=4, wt=avg_log2FC) -> top4

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top4$gene,raster=F)

ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top4.png")
```


# Pull out new cluster specific CLECs 
```{r}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(grepl("clec*",gene), p_val_adj < .01) %>% top_n(n=2, wt=avg_log2FC) -> top2clecs

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top2clecs$gene,raster=F)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top2clecs.png")
```


# Pull out cluster specific SPPs 
```{r fig.height=4, fig.width=7}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(grepl("^spp",gene), p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10spps

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top10spps$gene,raster=F)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top10spp.png")
```

# Pull out cluster specific IRGs 
```{r fig.height=4, fig.width=7}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(grepl("^irg",gene), p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10irgs

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top10irgs$gene,raster=F)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top10irg.png")
```



# plot genes of interest
From John Murray dataset 
    - intestine_anterior: ZC204.12, cpr-1, ceh-37
    - intestine_middle_and_posterior: irg-7, pal-1, cpr-1, ceh-37
    - intestine_far_posterior: irg-7, faah-1, pbo-4, psa-3

```{r}
# top marker gene for each cluster
FeaturePlot(emb.GFPpooled.specificClusters.recluster, pt.size = 0.1,
            features = (emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% slice_max(n = 1, order_by = avg_log2FC))$gene)
```

```{r}
# genes from murray data
# intestine_anterior
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('ZC204.12', 'cpr-1', 'ceh-37'), raster=F, ncol = 2)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.Murray-Anterior.png") 

# intestine_middle_and_posterior
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('irg-7', 'pal-1', 'cpr-1', 'ceh-37'), raster=F, ncol = 2)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.Murray-Mid.png")

# intestine_far_posterior
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('faah-1', 'pbo-4', 'psa-3'), raster=F, ncol = 2)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.Murray-Posterior.png")
```



# Assign cell type identity to clusters 
```
new.cluster.ids <- c("Naive CD4 T", "CD14+ Mono", "Memory CD4 T", "B", "CD8 T", "FCGR3A+ Mono",
    "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

