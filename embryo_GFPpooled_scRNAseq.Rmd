---
title: "embryo_intestine_scRNAseq"
author: "Jessica Hill"
date: "9/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---

# Install packages
```{r}
#install.packages('Seurat')
#packageVersion('Seurat') # 5.3.0
#install.packages('Matrix')
#install.packages("hdf5r")
#install.packages("clustree")
#install.packages("tidyverse")
#install.packages("patchwork")
#install.packages("remotes")
#install.packages("R.utils")


# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install(version = "3.21")
#BiocManager::install(version = "3.19") #cant use with this version of R anymore

#BiocManager::install("biomaRt")

#BiocManager::install('multtest')
#install.packages('metap')

#install.packages('devtools')
```

# Load packages
```{r echo=FALSE}
#library(biomaRt)
#library(Seurat)
#library(ggplot2)
#library(tidyverse)
#library(patchwork)
#library(clustree)
#library(metap)
```

---
count matrix
QC and filtering
Normalization
Linear dimensionality reduction (PCA)
Scale data
Identify highly variable genes
Clustering
Non-linear dimensional reduction (UMAP/t-SNE)
---

# Load the data
```{r}
emb.GFPpooled_v2.data <- Read10X_h5("./cellranger/all_GFP_v2/filtered_feature_bc_matrix.h5")

emb.ALLpooled_v2.data <- Read10X_h5("./cellranger/all_pooled_v2/filtered_feature_bc_matrix.h5")
```



Get filternames from https://parasite.wormbase.org/biomart/martview
```{r}
mart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)

genes.df <- getBM(mart = mart, 
      filters = c("species_id_1010", "gene_name"),
      value = list("caelegprjna13758", rownames(emb.ALLpooled_v2.data)),
      attributes = c('wbps_gene_id','external_gene_id', 'chromosome_name'))

mitoList = genes.df[genes.df$chromosome_name == 'MtDNA', 'external_gene_id']
genes.df$chromosome_name = NULL

c(nrow(genes.df), nrow(emb.ALLpooled_v2.data))

# there are genes missing
nrow(emb.ALLpooled_v2.data)-nrow(genes.df)
```
```{r}
mart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)

genes1.df <- getBM(mart = mart, 
      filters = c("species_id_1010", "gene_name"),
      value = list("caelegprjna13758", rownames(emb.GFPpooled_v2.data)),
      attributes = c('wbps_gene_id','external_gene_id', 'chromosome_name'))

mitoList1 = genes1.df[genes1.df$chromosome_name == 'MtDNA', 'external_gene_id']
genes1.df$chromosome_name = NULL

c(nrow(genes1.df), nrow(emb.GFPpooled_v2.data))

# there are genes missing
nrow(emb.GFPpooled_v2.data)-nrow(genes1.df)
```



Remove missing genes (`nrow(emb.GFPpooled.data)-nrow(genes.df)`) from the input matrix 
```{r}
emb.ALLpooled_v2.data.filt <- emb.ALLpooled_v2.data[rownames(emb.ALLpooled_v2.data) %in% genes.df$external_gene_id,]

# The two data structures do not have the same order of WBGeneIDs
identical(rownames(emb.ALLpooled_v2.data.filt), genes.df$external_gene_id)

# Use match to make sure they are in the same order
identical(rownames(emb.ALLpooled_v2.data.filt),
          genes.df[match(rownames(emb.ALLpooled_v2.data.filt), genes.df$external_gene_id),]$external_gene_id)

# are there NAs?
sum(!is.na(rownames(emb.ALLpooled_v2.data.filt)))

head(emb.ALLpooled_v2.data.filt)
```
```{r}
emb.GFPpooled_v2.data.filt <- emb.GFPpooled_v2.data[rownames(emb.GFPpooled_v2.data) %in% genes1.df$external_gene_id,]

# The two data structures do not have the same order of WBGeneIDs
identical(rownames(emb.GFPpooled_v2.data.filt), genes1.df$external_gene_id)

# Use match to make sure they are in the same order
identical(rownames(emb.GFPpooled_v2.data.filt),
          genes1.df[match(rownames(emb.GFPpooled_v2.data.filt), genes1.df$external_gene_id),]$external_gene_id)

# are there NAs?
sum(!is.na(rownames(emb.GFPpooled_v2.data.filt)))

head(emb.GFPpooled_v2.data.filt)
```



```{r}
# extract the cell codes (barcode info with the trailing integer which signifies the order of the samples in the aggregation step)
cellcodes <- as.data.frame(emb.ALLpooled_v2.data.filt@Dimnames[[2]])
colnames(cellcodes) <- "barcodes"
rownames(cellcodes) <- cellcodes$barcodes

cellcodes$rep_group <- dplyr::case_when(
  grepl("-(1|5)$", cellcodes$barcodes) ~ "Rep_1",
  grepl("-(2|6)$", cellcodes$barcodes) ~ "Rep_2",
  grepl("-(3|7)$", cellcodes$barcodes) ~ "Rep_3",
  grepl("-(4|8)$", cellcodes$barcodes) ~ "Rep_4",
  TRUE ~ "Unknown"
)

view(cellcodes)


cellcodes$condition <- dplyr::case_when(
  grepl("-(1|2|3|4)$", cellcodes$barcodes) ~ "GFP",
  grepl("-(5|6|7|8)$", cellcodes$barcodes) ~ "Unsorted",
  TRUE ~ "Unknown"
)

view(cellcodes)
```
```{r}
cellcodes_1 <- as.data.frame(emb.GFPpooled_v2.data.filt@Dimnames[[2]])
colnames(cellcodes_1) <- "barcodes"
rownames(cellcodes_1) <- cellcodes_1$barcodes 

cellcodes_1$rep_group <- dplyr::case_when(
  grepl("-1$", cellcodes_1$barcodes) ~ "Rep_1",
  grepl("-2$", cellcodes_1$barcodes) ~ "Rep_2",
  grepl("-3$", cellcodes_1$barcodes) ~ "Rep_3",
  grepl("-4$", cellcodes_1$barcodes) ~ "Rep_4",
  TRUE ~ "Unknown"
)

view(cellcodes_1)


cellcodes_1$condition <- dplyr::case_when(
  grepl("-(1|2|3|4)$", cellcodes_1$barcodes) ~ "GFP",
  TRUE ~ "Unknown"
)

view(cellcodes_1)
```




```{r}
# Check data for mismatch. Make sure that rownames(cellcodes) and colnames(counts) match.

all(colnames(emb.ALLpooled_v2.data.filt) == rownames(cellcodes))
all(colnames(emb.GFPpooled_v2.data.filt) == rownames(cellcodes_1))
```


# Set up the Seurat object
# Initialize the Seurat object with the raw (non-normalized data).
```{r}
emb.ALLpooled_v2 <- CreateSeuratObject(counts = emb.ALLpooled_v2.data.filt, project = "emb.ALLpooled_v2", min.cells = 3, min.features = 200, meta.data = cellcodes)

view(emb.ALLpooled_v2@meta.data)
```
```{r}
emb.GFPpooled_v2 <- CreateSeuratObject(counts = emb.GFPpooled_v2.data.filt, project = "emb.GFPpooled_v2", min.cells = 3, min.features = 200, meta.data = cellcodes_1)

view(emb.GFPpooled_v2@meta.data)
```



Create a list of Seurat objects, one for each rep_group. Can now loop over these for normalization, variable feature detection, etc.
```{r}
emb.ALLpooled_v2[["RNA"]] <- split(emb.ALLpooled_v2[["RNA"]], f = emb.ALLpooled_v2$rep_group)
emb.ALLpooled_v2
```
```{r}
emb.GFPpooled_v2[["RNA"]] <- split(emb.GFPpooled_v2[["RNA"]], f = emb.GFPpooled_v2$rep_group)
emb.GFPpooled_v2
```




```
# this code chunk wont work becuase i havent renamed the rownames of the count matrix (seurat object)!!

length(unique(genes.df$wbps_gene_id))
length(unique(rownames(emb.ALLpooled_v2)))
rownames(emb.ALLpooled_v2)[!(rownames(emb.ALLpooled_v2) %in% genes.df$external_gene_id)]


length(unique(genes1.df$wbps_gene_id))
length(unique(rownames(emb.GFPpooled_v2)))
rownames(emb.GFPpooled_v2)[!(rownames(emb.GFPpooled_v2) %in% genes1.df$external_gene_id)]
```



# Quality control metrics
- `nFeature_RNA` is the number of genes detected in each cell. 
- `nCount_RNA` is the total number of molecules detected within a cell (AKA total UMIs per cell)
- Low `nFeature_RNA` indicates that the cell may be dead or dying or an empty droplet
- High `nCount_RNA` and/or `nFeature_RNA` indicates that the "cell" may in fact be a doublet (or multiplet)

```{r}
# show QC metrics for the first 5 cells 
view(emb.ALLpooled_v2@meta.data)
head(emb.ALLpooled_v2@meta.data, 5)
```
```{r}
view(emb.GFPpooled_v2@meta.data)
head(emb.GFPpooled_v2@meta.data, 5)
```


Mitochondrial genome percentage 
```{r}
mitoIndices <- rownames(emb.ALLpooled_v2)[rownames(emb.ALLpooled_v2) %in% mitoList]
emb.ALLpooled_v2[["percent.mt"]] <- PercentageFeatureSet(emb.ALLpooled_v2, features = mitoIndices)
```
```{r}
mitoIndices_1 <- rownames(emb.GFPpooled_v2)[rownames(emb.GFPpooled_v2) %in% mitoList1]
emb.GFPpooled_v2[["percent.mt"]] <- PercentageFeatureSet(emb.GFPpooled_v2, features = mitoIndices_1)
```



Visualize QC metrics as a violin plot
```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.VlnPlot.pdf", height = 6, width = 9)
VlnPlot(emb.ALLpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VlnPlot.pdf", height = 6, width = 9)
VlnPlot(emb.GFPpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
dev.off()
```

FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeatureScatter.pdf", height = 6, width = 9)
plot1 <- FeatureScatter(emb.ALLpooled_v2, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.ALLpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeatureScatter.pdf", height = 6, width = 9)
plot1 <- FeatureScatter(emb.GFPpooled_v2, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.GFPpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
dev.off()
```


Filter based on features.
cells being filtered due to mito percent: 
```{r}
sum(emb.ALLpooled_v2$percent.mt > 50)/ length(emb.ALLpooled_v2$percent.mt)
emb.ALLpooled_v2 <- subset(emb.ALLpooled_v2, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)
```
```{r}
sum(emb.GFPpooled_v2$percent.mt > 50)/ length(emb.GFPpooled_v2$percent.mt)
emb.GFPpooled_v2 <- subset(emb.GFPpooled_v2, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)
```


Visualize after filtering
```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.VlnPlot.filt.pdf", height = 6, width = 9)
VlnPlot(emb.ALLpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"))
dev.off()

pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeatureScatter.filt.pdf", height = 6, width = 9)
FeatureScatter(emb.ALLpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VlnPlot.filt.pdf", height = 6, width = 9)
VlnPlot(emb.GFPpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeatureScatter.filt.pdf", height = 6, width = 9)
FeatureScatter(emb.GFPpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
dev.off()
```

```{r}
view(emb.ALLpooled_v2@meta.data)
hist(emb.ALLpooled_v2$nFeature_RNA)
hist(emb.ALLpooled_v2$nCount_RNA)

view(emb.ALLpooled_v2@assays$RNA$counts)
exp_matrix <- as.matrix(emb.ALLpooled_v2@assays$RNA$counts)
gene_express_per_cell <- rowSums(exp_matrix)
genes_express_only_once <- sum(gene_express_per_cell==1)
```
```{r}
view(emb.GFPpooled_v2@meta.data)
hist(emb.GFPpooled_v2$nFeature_RNA)
hist(emb.GFPpooled_v2$nCount_RNA)

view(emb.GFPpooled_v2@assays$RNA$counts)
exp_matrix1 <- as.matrix(emb.GFPpooled_v2@assays$RNA$counts)
gene_express_per_cell1 <- rowSums(exp_matrix1)
genes_express_only_once1 <- sum(gene_express_per_cell1==1)
```

# Normalize the data
After removing unwanted cells from the dataset, we next normalize the data. 
By default, we employ a global-scaling normalization method "LogNormalize" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 is the default), and log-transforms the result. 

Normalized values are stored in emb.GFPpooled[["RNA]]@data

```{r}
library(sctransform)

emb.ALLpooled_v2 <- NormalizeData(emb.ALLpooled_v2, normalization.method = "LogNormalize", scale.factor = 10000)
```
```{r}
emb.GFPpooled_v2 <- NormalizeData(emb.GFPpooled_v2, normalization.method = "LogNormalize", scale.factor = 10000)
```


# Feature selection
Identify highly variable features to focus on in downstream analysis
```{r}
emb.ALLpooled_v2 <- FindVariableFeatures(emb.ALLpooled_v2, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10_all <- head(VariableFeatures(emb.ALLpooled_v2), 10)

# plot variable features with and without labels
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.VarFeatures.pdf", height = 6, width = 9)
plot1 <- VariableFeaturePlot(emb.ALLpooled_v2)
LabelPoints(plot = plot1, points = top10_all, repel = TRUE)
dev.off()
```
```{r}
emb.GFPpooled_v2 <- FindVariableFeatures(emb.GFPpooled_v2, selection.method = "vst", nfeatures = 2000)

top10_GFP <- head(VariableFeatures(emb.GFPpooled_v2), 10)

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VarFeatures.pdf", height = 6, width = 9)
plot1 <- VariableFeaturePlot(emb.GFPpooled_v2)
LabelPoints(plot = plot1, points = top10_GFP, repel = TRUE)
dev.off()
```


# Scaling the data
Apply a linear transformation ("scaling") prior to dimensional reduction, PCA. 
Shifts the expression of each gene, so that the mean expression across cells is 0. 
Scales the expression of each gene, so that the variance across cells is 1. 
This gives equal weight in downstream analysis, so that highly expressed genes dont dominate. 
```{r}
all.genes <- rownames(emb.ALLpooled_v2)
emb.ALLpooled_v2 <- ScaleData(emb.ALLpooled_v2, features = all.genes)
```
```{r}
all.genes_1 <- rownames(emb.GFPpooled_v2)
emb.GFPpooled_v2 <- ScaleData(emb.GFPpooled_v2, features = all.genes_1)
```


# Linear dimensional reduction 
perform PCA on the scaled data. 
By default, only the previously determined variable features are used as input. 
```{r}
emb.ALLpooled_v2 <- RunPCA(emb.ALLpooled_v2, features = VariableFeatures(object = emb.ALLpooled_v2))
```
```{r}
emb.GFPpooled_v2 <- RunPCA(emb.GFPpooled_v2, features = VariableFeatures(object = emb.GFPpooled_v2))
```

Examine and visualize PCA results a few different ways
```{r}
print(emb.ALLpooled_v2[["pca"]], dims = 1:5, nfeatures = 5)
```
```{r}
print(emb.GFPpooled_v2[["pca"]], dims = 1:5, nfeatures = 5)
```

```{r}
# top genes associated with reduction components
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.DimLoadings.pdf", height = 6, width = 9)
VizDimLoadings(emb.ALLpooled_v2, dims = 1:2, reduction = "pca")
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.DimLoadings.pdf", height = 6, width = 9)
VizDimLoadings(emb.GFPpooled_v2, dims = 1:2, reduction = "pca")
dev.off()
```

```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.DimPlot.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "pca")
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.DimPlot.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "pca")
dev.off()
```

```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.HeatMap1.pdf", height = 6, width = 9)
DimHeatmap(emb.ALLpooled_v2, dims = 1, cells = 500, balanced = TRUE)
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.HeatMap1.pdf", height = 6, width = 9)
DimHeatmap(emb.GFPpooled_v2, dims = 1, cells = 500, balanced = TRUE)
dev.off()
```

```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.HeatMap1-6.pdf", height = 6, width = 9)
DimHeatmap(emb.ALLpooled_v2, dims = 1:6, cells = 500, balanced = TRUE)
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.HeatMap1-6.pdf", height = 6, width = 9)
DimHeatmap(emb.GFPpooled_v2, dims = 1:6, cells = 500, balanced = TRUE)
dev.off()
```


# Determine dataset dimensionality
To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a ‘metafeature’ that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many components should we choose to include? 

Seurat implements a resampling test inspired by the JackStraw procedure. We randomly permute a subset of the data (1% by default) and rerun PCA, constructing a ‘null distribution’ of feature scores, and repeat this procedure. We identify ‘significant’ PCs as those who have a strong enrichment of low p-value features
```{r}
emb.ALLpooled_v2 <- JackStraw(emb.ALLpooled_v2, num.replicate = 100)
emb.ALLpooled_v2 <- ScoreJackStraw(emb.ALLpooled_v2, dims = 1:20)
```
```{r}
emb.GFPpooled_v2 <- JackStraw(emb.GFPpooled_v2, num.replicate = 100)
emb.GFPpooled_v2 <- ScoreJackStraw(emb.GFPpooled_v2, dims = 1:20)
```

The JackStrawPlot() function provides a visualization tool for comparing the distribution of p-values for each PC with a uniform distribution (dashed line). ‘Significant’ PCs will show a strong enrichment of features with low p-values (solid curve above the dashed line). 
```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.JackStrawPlot.pdf", height = 6, width = 9)
JackStrawPlot(emb.ALLpooled_v2, dims = 1:20)
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.JackStrawPlot.pdf", height = 6, width = 9)
JackStrawPlot(emb.GFPpooled_v2, dims = 1:20)
dev.off()
```


An alternative heuristic method generates an ‘Elbow plot’: a ranking of principle components based on the percentage of variance explained by each one.
```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.ElbowPlot.pdf", height = 6, width = 9)
ElbowPlot(emb.ALLpooled_v2)
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ElbowPlot.pdf", height = 6, width = 9)
ElbowPlot(emb.GFPpooled_v2)
dev.off()
```

The elbow plot is helpful when determining how many PCs we need to capture the majority of the variation in the data. The elbow plot visualizes the standard deviation of each PC. Where the elbow appears is usually the threshold for identifying the majority of the variation. However, this method can be a bit subjective about where the elbow is located.


# Cluster the cells
Seurat applies a graph-based clustering approach.

Seurat first constructs a KNN graph based on the euclidean distance in PCA space, and refines the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset.

To cluster the cells, Seurat then applies modularity optimization techniques such as the Louvain algorithm (default) or SLM, to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters() function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters.
```{r}
emb.ALLpooled_v2 <- FindNeighbors(emb.ALLpooled_v2, dims = 1:20)

# deviation form original seurat pipeline
# generate a vector of different resolutions to see which one performs best 
emb.ALLpooled_v2.clust <- FindClusters(
  object = emb.ALLpooled_v2,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:20,
  save.SNN = TRUE)

clustree(emb.ALLpooled_v2.clust, prefix = "RNA_snn_res.")


## Now use Clustree to build a clustering tree based on the chosen resolutions specified above 
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.Clustree.pdf", height = 6, width = 9)
clustree(emb.ALLpooled_v2.clust, prefix = "RNA_snn_res.")
dev.off()


# can also see how the different resolutions look like this
DimPlot(emb.ALLpooled_v2.clust, group.by = "RNA_snn_res.0.8", label = TRUE)
```
```{r}
emb.GFPpooled_v2 <- FindNeighbors(emb.GFPpooled_v2, dims = 1:20)


emb.GFPpooled_v2.clust <- FindClusters(
  object = emb.GFPpooled_v2,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:20,
  save.SNN = TRUE)


clustree(emb.GFPpooled_v2.clust, prefix = "RNA_snn_res.")


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.Clustree.pdf", height = 6, width = 9)
clustree(emb.GFPpooled_v2.clust, prefix = "RNA_snn_res.")
dev.off()


# can also see how the different resolutions look like this
DimPlot(emb.GFPpooled_v2.clust, group.by = "RNA_snn_res.0.8", label = TRUE)
```


```{r}
# now choose the appropriate resolution for the given dimensions using the Clustree data
emb.ALLpooled_v2 <- FindClusters(emb.ALLpooled_v2, resolution = 1.2, cluster.name = "unintegrated_clusters")
```
```{r}
emb.GFPpooled_v2 <- FindClusters(emb.GFPpooled_v2, resolution = 1.2, cluster.name = "unintegrated_clusters")
```



# Run non-linear dimensional reduction (UMAP or tSNE)
Visualize and explore data with UMAP or tSNE.
The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP or tSNE, it is suggested to use the same PCs as input to the clustering analysis.
```{r}
emb.ALLpooled_v2 <- RunUMAP(emb.ALLpooled_v2, dims = 1:20, reduction = "pca", reduction.name = "umap.unintegrated")
```
```{r}
emb.GFPpooled_v2 <- RunUMAP(emb.GFPpooled_v2, dims = 1:20, reduction = "pca", reduction.name = "umap.unintegrated")
```

```{r}
# Note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.UMAP.unint.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "umap.unintegrated", group.by = c("rep_group", "seurat_clusters"), label = "TRUE", label.box = TRUE, label.size = 4, pt.size = 1) 
# + theme(axis.title.x = element_text(size = 20),
#         axis.ticks.x = element_line(size = 6),
#         axis.title.y = element_text(size = 20),
#         axis.ticks.y = element_line(size = 6),
#         legend.text = element_text(size = 20))
dev.off()


pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.UMAP.unint2.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "umap.unintegrated", group.by = c("rep_group", "seurat_clusters"))
dev.off()


pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.UMAP.unint.rep.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "umap.unintegrated", split.by = "rep_group")
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.unint.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", group.by = c("rep_group", "seurat_clusters"), label = "TRUE", label.box = TRUE, label.size = 4, pt.size = 1) 
# + theme(axis.title.x = element_text(size = 20),
#         axis.ticks.x = element_line(size = 6),
#         axis.title.y = element_text(size = 20),
#         axis.ticks.y = element_line(size = 6),
#         legend.text = element_text(size = 20))
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.unint2.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", group.by = c("rep_group", "seurat_clusters"))
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.unint.rep.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", split.by = "rep_group")
dev.off()
```



# Perform integration 
Aims to return a single dimensional reduction that captures the shared sources of variance across multiple layers, so that cells in a similar biological state will cluster. The method returns a dimensional reduction (i.e. integrated.cca, harmony) which can be used for visualization and unsupervised clustering analysis. 


Harmony
```{r}
#install.packages("harmony")
#library(harmony)
set.seed(42)
```
```{r}
emb.ALLpooled_v2 <- IntegrateLayers(object = emb.ALLpooled_v2, method = HarmonyIntegration, orig.reduction = "pca", new.reduction = "harmony",
    verbose = FALSE)

# re-join layers after integration
emb.ALLpooled_v2[["RNA"]] <- JoinLayers(emb.ALLpooled_v2[["RNA"]])

emb.ALLpooled_v2 <- FindNeighbors(emb.ALLpooled_v2, reduction = "harmony", dims = 1:20)
emb.ALLpooled_v2 <- FindClusters(emb.ALLpooled_v2, resolution = 1.2, cluster.name = "harmony_clusters")
emb.ALLpooled_v2 <- RunUMAP(emb.ALLpooled_v2, dims = 1:20, reduction = "harmony", reduction.name = "umap.harmony")


pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.UMAP.int.harmony.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "umap.harmony", group.by = c("rep_group", "seurat_clusters"))
dev.off()


pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.UMAP.int.harmony.rep.pdf", height = 6, width = 9)
DimPlot(emb.ALLpooled_v2, reduction = "umap.harmony", split.by = "rep_group")
dev.off()


pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.UMAP.int.harmony2.pdf", height = 6, width = 6)
DimPlot(emb.ALLpooled_v2, reduction = "umap.harmony", label = TRUE, pt.size = 1, label.size = 4) + theme(legend.text = element_text(size = 10))
dev.off()

#labels = c('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')
```
```{r}
emb.GFPpooled_v2 <- IntegrateLayers(object = emb.GFPpooled_v2, method = HarmonyIntegration, orig.reduction = "pca", new.reduction = "harmony",
    verbose = FALSE)

# re-join layers after integration
emb.GFPpooled_v2[["RNA"]] <- JoinLayers(emb.GFPpooled_v2[["RNA"]])

emb.GFPpooled_v2 <- FindNeighbors(emb.GFPpooled_v2, reduction = "harmony", dims = 1:20)
emb.GFPpooled_v2 <- FindClusters(emb.GFPpooled_v2, resolution = 1.2, cluster.name = "harmony_clusters")

emb.GFPpooled_v2 <- RunUMAP(emb.GFPpooled_v2, dims = 1:20, reduction = "harmony", reduction.name = "umap.harmony")


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.int.harmony.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.harmony", group.by = c("rep_group", "seurat_clusters"))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.int.harmony.rep.pdf", height = 6, width = 9)
DimPlot(emb.GFPpooled_v2, reduction = "umap.harmony", split.by = "rep_group")
dev.off()
```

```{r}
# so variability in the umap projections is coming from the integration (harmony) not from the PCA or umap, those have a set.seed default = 42
# so need to set a global seed


emb.GFPpooled_v2@reductions$pca
emb.GFPpooled_v2@reductions$umap.unintegrated
emb.GFPpooled_v2@reductions$harmony
emb.GFPpooled_v2@reductions$umap.harmony


DimPlot(emb.GFPpooled_v2, reduction = "pca", split.by = "rep_group")
DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", split.by = "rep_group")
DimPlot(emb.GFPpooled_v2, reduction = "harmony", split.by = "rep_group")
DimPlot(emb.GFPpooled_v2, reduction = "umap.harmony", split.by = "rep_group")
```


output total gene list for cells in clusters (not just variable features)
```{r}
# `nFeature_RNA` is the number of genes detected in each cell. 
# `nCount_RNA` is the total number of molecules detected within a cell (AKA total UMIs per cell)

head(emb.GFPpooled_v2@meta.data)
head(emb.GFPpooled_v2@assays$RNA$data)

write.csv(emb.GFPpooled_v2@meta.data,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2_meta.data.csv", row.names = TRUE)

write.csv(emb.GFPpooled_v2@assays$RNA$data,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.csv", row.names = TRUE)
```

# Find differentially expressed features (cluster biomarkers)
Find markers that define clusters via differential expression. By default, Seurat identifies positive and negative markers of a single cluster compared to all other cells. You can do for all clusters, you can test groups of clusters vs. each other, or against all cells. 

The min.pct argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the thresh.test argument requires a feature to be differentially expressed (on average) by some amount between the two groups. max.cells.per.ident can also be set and will downsample each identity class to have no more cells than whatever this is set to. 
```{r}
emb.GFPpooled_v2.markers <- FindAllMarkers(emb.GFPpooled_v2, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

emb.GFPpooled_v2.markers %>% 
  group_by(cluster) %>% filter(p_val_adj < .01) %>%
  slice_max(n = 2, order_by = avg_log2FC) 

write.csv(emb.GFPpooled_v2.markers,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2_markers.csv", row.names = TRUE)
```
```{r}
emb.ALLpooled_v2.markers <- FindAllMarkers(emb.ALLpooled_v2, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

emb.ALLpooled_v2.markers %>% 
  group_by(cluster) %>% filter(p_val_adj < .01) %>%
  slice_max(n = 2, order_by = avg_log2FC) 

write.csv(emb.ALLpooled_v2.markers,"./Seurat_output/all_pooled_v2/emb.ALLpooled_v2_markers.csv", row.names = TRUE)
```


checking which clusters are intestinal based on the expression of known intestine marker genes
```{r}
pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeaturePlot.INTmarkergenes.pdf", height = 6, width = 9)
FeaturePlot(emb.ALLpooled_v2, reduction = "umap.harmony", features = c("elt-2", "elt-7", "ges-1", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)
dev.off()


FeaturePlot(emb.ALLpooled_v2, reduction = "umap.unintegrated", features = c("elt-2", "elt-7", "ges-1", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)



pdf("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeaturePlot.alltissuemarkergenes.pdf", height = 12, width = 9)
FeaturePlot(emb.ALLpooled_v2, reduction = "umap.harmony", features = c("elt-2", "elt-7", "ges-1", "glh-1", "nos-1", "pgl-1", "myo-3", "pat-10", "mls-1", "rab-3", "odr-2",  "mec-7", "myo-2", "tnc-2", "phat-2", "elt-1", "elt-3", "dpy-7"), ncol = 3, coord.fixed = TRUE)
dev.off()


#VlnPlot(object = emb.ALLpooled_v2, features = c("ugt-14", "c10c5.4", "acp-2", "end-1"))
#VlnPlot(object = emb.ALLpooled_v2, features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"))


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeaturePlot.INTmarkergenes.pdf", height = 6, width = 9)
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.harmony", features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)
dev.off()


#VlnPlot(object = emb.GFPpooled_v2, features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"))

DimPlot(emb.GFPpooled_v2, reduction = "umap.harmony", group.by = "seurat_clusters", label = "TRUE", label.box = TRUE, label.size = 4, pt.size = 1)
```



# Remove contamination clusters
clusters we want to keep = 1, 2, 5, 11, 14, 15, 16
based on above checking of intestine marker genes
contamination clusters = 0, 3, 4, 6, 7, 8, 9, 10, 12, 13, 17, 18, 19, 20
```{r}
emb.GFPpooled_v2.filteredClusters <- subset(emb.GFPpooled_v2, idents = c('0', '3', '4', '6', '7', '8', '9', '10', '12', '13', '17', '18', '19'), invert = TRUE)
emb.GFPpooled_v2.filteredClusters <- RunPCA(emb.GFPpooled_v2.filteredClusters)
ElbowPlot(emb.GFPpooled_v2.filteredClusters)
emb.GFPpooled_v2.filteredClusters <- FindNeighbors(emb.GFPpooled_v2.filteredClusters, dims = 1:10)
emb.GFPpooled_v2.filteredClusters <- FindClusters(emb.GFPpooled_v2.filteredClusters, resolution = 1.2)
emb.GFPpooled_v2.filteredClusters <- RunUMAP(emb.GFPpooled_v2.filteredClusters, dims = 1:10)
DimPlot(emb.GFPpooled_v2.filteredClusters, reduction = "umap", label = TRUE)

#check clusters for expression of intestine marker genes
FeaturePlot(emb.GFPpooled_v2.filteredClusters, reduction = "umap", features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)

VlnPlot(object = emb.GFPpooled_v2.filteredClusters, features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"))




emb.GFPpooled_v2.finalfiltClusters <- subset(emb.GFPpooled_v2.filteredClusters, idents = c('11'), invert = TRUE)
emb.GFPpooled_v2.finalfiltClusters <- RunPCA(emb.GFPpooled_v2.finalfiltClusters)
ElbowPlot(emb.GFPpooled_v2.finalfiltClusters)
emb.GFPpooled_v2.finalfiltClusters <- FindNeighbors(emb.GFPpooled_v2.finalfiltClusters, dims = 1:10)
emb.GFPpooled_v2.finalfiltClusters <- FindClusters(emb.GFPpooled_v2.finalfiltClusters, resolution = 1.2)
emb.GFPpooled_v2.finalfiltClusters <- RunUMAP(emb.GFPpooled_v2.finalfiltClusters, dims = 1:10)
DimPlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", label = TRUE)

#check clusters for expression of intestine marker genes
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)

VlnPlot(object = emb.GFPpooled_v2.finalfiltClusters, features = c("elt-2", "elt-7", "ges-1", "end-1", "end-3", "ifb-2", "act-5"))
```

```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.UMAP.pdf", height = 6, width = 6)
DimPlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", pt.size = 1) 
# + theme(axis.title.x = element_text(size = 20),
#         axis.ticks.x = element_line(size = 6),
#         axis.title.y = element_text(size = 20),
#         axis.ticks.y = element_line(size = 6),
#         legend.text = element_text(size = 20))
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.UMAP-lab.pdf", height = 6, width = 6)
DimPlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", pt.size = 1, label = TRUE, label.size = 6) + theme(legend.text = element_text(size = 10))
#DimPlot(emb.ALLpooled_v2, reduction = "umap.harmony", label = TRUE, pt.size = 1, label.size = 4) + theme(legend.text = element_text(size = 10))
dev.off()




#check clusters for expression of intestine marker genes
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.FeaturePlot.INTmarkergenes.pdf", height = 6, width = 9)
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("elt-2", "elt-7", "ges-1", "ifb-2", "act-5"), ncol = 3, coord.fixed = TRUE)
dev.off()
```



```{r}
emb.GFPpooled_v2.finalfiltClusters.markers <- FindAllMarkers(emb.GFPpooled_v2.finalfiltClusters, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

emb.GFPpooled_v2.finalfiltClusters.markers %>% 
  group_by(cluster) %>% filter(p_val_adj < .01) %>%
  slice_max(n = 2, order_by = avg_log2FC) 

write.csv(emb.GFPpooled_v2.finalfiltClusters.markers,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2_finalfiltClusters_markers.csv", row.names = TRUE)
```

```{r}
#The UMAP embeddings are stored in the Seurat object under the reductions slot. Extract the number of cells by checking the number of rows in the UMAP embedding matrix. Counting the number of rows in this matrix, directly corresponds to the number of cells that have UMAP embeddings.

num_int_cells <- nrow(Embeddings(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap"))
print(paste("Number of intestinal cells in UMAP:", num_int_cells))

num_all_cells <- nrow(Embeddings(emb.ALLpooled_v2, reduction = "umap.harmony"))
print(paste("Number of all cells in UMAP:", num_all_cells))
```


# make some pretty heatmaps 
```{r}
emb.GFPpooled_v2.finalfiltClusters.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=2, wt=avg_log2FC) -> top2

emb.GFPpooled_v2.finalfiltClusters.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=1, wt=avg_log2FC) -> top1

emb.GFPpooled_v2.finalfiltClusters.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) -> all

emb.GFPpooled_v2.finalfiltClusters.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=15, wt=avg_log2FC) -> almost_all


# Erin wants to see the smiFISH targets in the heat map as well
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.markers.HeatMap-top2.pdf", height = 6, width = 15)
DoHeatmap(emb.GFPpooled_v2.finalfiltClusters, features = c(top2$gene), raster=F) + 
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.HeatMap-top1.pdf", height = 6, width = 15)
DoHeatmap(emb.GFPpooled_v2.finalfiltClusters, features = c(top1$gene), raster=F) + 
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.HeatMap-top1.smifish.pdf", height = 6, width = 15)
DoHeatmap(emb.GFPpooled_v2.finalfiltClusters, features = c(top1$gene, "clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F) +
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()


pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.HeatMap-smiFISH.pdf", height = 6, width = 15)
DoHeatmap(emb.GFPpooled_v2.finalfiltClusters, features = c("clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F) + 
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()



pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.HeatMap-all.pdf", height = 12, width = 30)
DoHeatmap(emb.GFPpooled_v2.finalfiltClusters, features = c(all$gene), raster=F) + 
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.HeatMap-almost_all_15.pdf", height = 12, width = 30)
DoHeatmap(emb.GFPpooled_v2.finalfiltClusters, features = c(almost_all$gene), raster=F) + theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()
```


```{r}
# RNAi 
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.rnai.pdf", height = 6, width = 15)  
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("C14C6.5", "cpr-1", "Y32F6A.5", "endu-2", "clec-56", "pbo-4", "ugt-14"), ncol = 3, coord.fixed = TRUE)
dev.off()


# intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.intestine.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("elt-2", "elt-7", "ges-1"), ncol = 3, coord.fixed = TRUE)
dev.off() 

#VlnPlot(object = emb.GFPpooled_v2.finalfiltClusters, features = c("elt-2", "elt-7", "ges-1"))


# germline
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.germ.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("glh-1", "nos-1", "pgl-1"), ncol = 3, coord.fixed = TRUE)
dev.off()

#VlnPlot(object = emb.GFPpooled_v2.finalfiltClusters, features = c("glh-1", "nos-1", "pgl-1"))


# muscle
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.muscle.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("myo-3", "pat-10", "lev-11"), ncol = 3, coord.fixed = TRUE)
dev.off()

#VlnPlot(object = emb.GFPpooled_v2.finalfiltClusters, features = c("myo-3", "pat-10", "lev-11"))


# neuron
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.neuron.pdf", height = 6, width = 15)
FeaturePlot(eemb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("rab-3", "odr-2", "mec-7"), ncol = 3, coord.fixed = TRUE)
dev.off()

#VlnPlot(object = emb.GFPpooled_v2.finalfiltClusters, features = c("rab-3", "odr-2", "mec-7"))

# pharynx
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.pharynx.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("myo-2", "tnc-2", "phat-2"), ncol = 3, coord.fixed = TRUE)
dev.off()

#VlnPlot(object = emb.GFPpooled_v2.finalfiltClusters, features = c("myo-2", "tnc-2", "phat-2"))


# hypodermis
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.hypodermis.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("elt-1", "elt-3", "dpy-7"), ncol = 3, coord.fixed = TRUE)
dev.off()

VlnPlot(object = emb.GFPpooled_v2.finalfiltClusters, features = c("elt-1", "elt-3", "dpy-7"))



# tissue marker genes
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.tissuemarkergenes.pdf", height = 10, width = 20)  
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("elt-2", "elt-7", "ges-1", "glh-1", "nos-1", "pgl-1", "rab-3", "odr-2", "mec-7", "myo-3", "pat-10", "lev-11", "myo-2", "tnc-2", "phat-2", "elt-1", "elt-3", "dpy-7"), ncol = 3, coord.fixed = TRUE)
dev.off()




# early intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.earlyint.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("end-1", "acp-2", "ugt-14", "C10C5.4"), ncol = 2 , coord.fixed = TRUE)
dev.off()

# mid intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.midint.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("T19D7.6", "T21E8.4", "C10A4.3", "klo-1"), ncol = 2 , coord.fixed = TRUE)
dev.off()
# (not the best) "T20D4.19", "F47B8.4"

# late intestine
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.featureplot.lateint.pdf", height = 6, width = 15)
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("C14C6.5", "clec-56", "cpr-1", "lec-9"), ncol = 2 , coord.fixed = TRUE)
dev.off()



#smiFISH targets
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.FeaturePlot-FISH.pdf", height = 10, width = 20)
FeaturePlot(emb.GFPpooled_v2.finalfiltClusters, reduction = "umap", features = c("C14C6.5", "cpr-1", "Y32F6A.5", "endu-2", "clec-56", "pbo-4", "ugt-14"), raster=F, ncol = 3, coord.fixed = TRUE) +
  theme(axis.title.x = element_text(size = 12),
        axis.text.x = element_text(size = 14),
        axis.title.y = element_text(size = 12),
        axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
dev.off()



VlnPlot(emb.GFPpooled_v2.finalfiltClusters, features = c("C14C6.5", "cpr-1", "Y32F6A.5"), raster=F, ncol = 2)
VlnPlot(emb.GFPpooled_v2.finalfiltClusters, features = "pbo-4", raster=F)
```



# how many cells are expressing these markers of other tissues?
```{r}
view(emb.GFPpooled_v2.finalfiltClusters@assays$RNA$data)

total_cells_expressing_gene <- sum(emb.GFPpooled_v2.finalfiltClusters@assays$RNA$data["hlh-2", ] > 0) #12
print(total_cells_expressing_gene)

total_cells_expressing_gene <- sum(emb.GFPpooled_v2.finalfiltClusters@assays$RNA$data["myo-3", ] > 0) #11
print(total_cells_expressing_gene)

total_cells_expressing_gene <- sum(emb.GFPpooled_v2.finalfiltClusters@assays$RNA$data["rab-3", ] > 0) #133
print(total_cells_expressing_gene)
```


# how many intestinal cells were in our all cells pooled sample?
```{r}
view(emb.ALLpooled_v2@assays$RNA$data)

unique_cells <- colSums(emb.ALLpooled_v2@assays$RNA$data[c("elt-2", "elt-7", "ges-1"), ] > 0) > 0
sum(unique_cells) # 1388

unique_cells <- sum(emb.ALLpooled_v2@assays$RNA$data["elt-2", ] > 0) #749
unique_cells <- sum(emb.ALLpooled_v2@assays$RNA$data["elt-7", ] > 0) #698
unique_cells <- sum(emb.ALLpooled_v2@assays$RNA$data["ges-1", ] > 0) #515
sum(unique_cells) 

b <- (749+698+515)
print(b)

total_cells <- ncol(emb.ALLpooled_v2@assays$RNA$data)
print(total_cells) #18748

a <- (1388/18748)*100
print(a) #7.5%

c <- (1962/18748)*100
print(c) #10%
```


---- alternate GO analysis
```{r}
Cluster0.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==0 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster1.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==1 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster2.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==2 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster3.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==3 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster4.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==4 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster5.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==5 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster6.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==6 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster7.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==7 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster8.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==8 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster9.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==9 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster10.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==10 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster11.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==11 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster12.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==12 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
Cluster13.markers <- emb.GFPpooled_v2.finalfiltClusters.markers[emb.GFPpooled_v2.finalfiltClusters.markers$cluster==13 & emb.GFPpooled_v2.finalfiltClusters.markers$p_val_adj < 0.05, ]
```
```{r}
BiocManager::install("Rsamtools")

install.packages("Signac")
install.packages("cowplot")

BiocManager::install("org.Ce.eg.db")
BiocManager::install("biovizBase")
#BiocManager::install(c('BSgenome.Hsapiens.UCSC.hg38', 'EnsDb.Hsapiens.v86'))
BiocManager::install("clusterProfiler")
BiocManager::install("enrichplot")
BiocManager::install("ggtree")

# load libraries
library(Signac)
library(cowplot)
library(clusterProfiler)
library(org.Ce.eg.db)
library(enrichplot)
library(ggtree)
```


```{r}
Cluster0.gene_ids <- bitr(Cluster0.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.37% of input gene IDs are fail to map...
Cluster1.gene_ids <- bitr(Cluster1.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.6% of input gene IDs are fail to map...
Cluster2.gene_ids <- bitr(Cluster2.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.17% of input gene IDs are fail to map...
Cluster3.gene_ids <- bitr(Cluster3.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #4.73% of input gene IDs are fail to map...
Cluster4.gene_ids <- bitr(Cluster4.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #1.36% of input gene IDs are fail to map...
Cluster5.gene_ids <- bitr(Cluster5.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.98% of input gene IDs are fail to map...
Cluster6.gene_ids <- bitr(Cluster6.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.64% of input gene IDs are fail to map...
Cluster7.gene_ids <- bitr(Cluster7.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.83% of input gene IDs are fail to map...
Cluster8.gene_ids <- bitr(Cluster8.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #4.89% of input gene IDs are fail to map...
Cluster9.gene_ids <- bitr(Cluster9.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #1.43% of input gene IDs are fail to map...
Cluster10.gene_ids <- bitr(Cluster10.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.3% of input gene IDs are fail to map...
Cluster11.gene_ids <- bitr(Cluster11.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.14% of input gene IDs are fail to map...
Cluster12.gene_ids <- bitr(Cluster12.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.56% of input gene IDs are fail to map...

Cluster13.gene_ids <- bitr(Cluster13.markers$gene, fromType = "SYMBOL",
                                   toType = "ENTREZID", OrgDb = org.Ce.eg.db) #2.72% of input gene IDs are fail to map...
```
```{r}
Cluster0.ego <- enrichGO(gene = Cluster0.gene_ids$ENTREZID, 
                OrgDb = org.Ce.eg.db, 
                ont = "BP", # biological process
                pAdjustMethod = "BH", 
                pvalueCutoff = 0.05, 
                qvalueCutoff = 0.05, 
                readable = TRUE)

```
```{r}
barplot(Cluster0.ego, showCategory=10, 
        title="GO Enrichment Analysis for Cluster 0")

```
```{r}
p1 <- dotplot(Cluster0.ego, showCategory=20, 
        title="GO Enrichment Analysis for Cluster 0")
p1 + theme(axis.text.y = element_text(size = 3))

```
```{r}
Cluster0.ego <- pairwise_termsim(Cluster0.ego)
emapplot(Cluster0.ego, showCategory=20)
```

#for all clusters 
```{r}
cluster_gene_list <- split(emb.GFPpooled_v2.finalfiltClusters.markers$gene, emb.GFPpooled_v2.finalfiltClusters.markers$cluster)

cluster_gene_list <- lapply(cluster_gene_list, function(genes) {
  gene_ids <- bitr(genes, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Ce.eg.db)
  return(gene_ids$ENTREZID)
})

#Use the compareCluster() function from clusterProfiler package to perform gene ontology analysis for all clusters together.

# GO enrichment analysis for BP
go_compare_bp <- compareCluster(geneCluster = cluster_gene_list, 
                             fun = "enrichGO", 
                             OrgDb = org.Ce.eg.db, 
                             ont = "BP",  # "BP"、"MF" or "CC"
                             pAdjustMethod = "BH",
                             pvalueCutoff = 0.05,
                             qvalueCutoff = 0.05)

bp <- simplify(go_compare_bp, cutoff=1, by="p.adjust", select_fun=min)

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.dotPlot-GO-BP.pdf", height = 10, width = 20)
cluster.p1 <- dotplot(bp, showCategory = 1,
              title = "GO Enrichment (Biological Process)")
cluster.p1 + theme(
  axis.text.y = element_text(size = 15),
  axis.text.x = element_text(size = 15),
  legend.text = element_text(size = 15)
  )
dev.off()


#Dot plots are not good for showing the relationship between GO terms. Can select and cluster GO terms first, and then use a tree plot to show the correlations between GO terms.
trim_bp <- pairwise_termsim(bp, showCategory = 50)
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.treeMap-GO-BP.pdf", height = 10, width = 20)
treeplot(trim_bp, showCategory = 5, layout = "circular", offset_tiplab = rel(0.4))
dev.off()
```
```{r}
#early int
VlnPlot(emb.GFPpooled_v2.finalfiltClusters, features = c('end-1', 'acp-2', 'ugt-14', 'C10C5.4'), raster=F)

#mid int
VlnPlot(emb.GFPpooled_v2.finalfiltClusters, features = c('T19D7.6', 'T21E8.4', 'klo-1', 'C10A4.3'), raster=F)

#late int
VlnPlot(emb.GFPpooled_v2.finalfiltClusters, features = c('C14C6.5', 'clec-56', 'cpr-1', 'lec-9'), raster=F)
  
clusters_to_use <- as.character(c(0:7, 9:13))
developmental.clusters.list <- cluster_gene_list[names(cluster_gene_list) %in% clusters_to_use]

go_compare_bp_dev <- compareCluster(geneCluster = developmental.clusters.list, 
                             fun = "enrichGO", 
                             OrgDb = org.Ce.eg.db, 
                             ont = "BP",  # "BP"、"MF" or "CC"
                             pAdjustMethod = "BH",
                             pvalueCutoff = 0.05,
                             qvalueCutoff = 0.05)

bp_dev <- simplify(go_compare_bp_dev, cutoff=1, by="p.adjust", select_fun=min)

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.dotPlot-GO-BP_developmental.pdf", height = 10, width = 20)
cluster.p1 <- dotplot(bp_dev, showCategory = 1,
              title = "GO Enrichment (Biological Process)")
cluster.p1 + theme(
  axis.text.y = element_text(size = 15),
  axis.text.x = element_text(size = 15),
  legend.text = element_text(size = 15)
  )
dev.off()


trim_bp_dev <- pairwise_termsim(bp_dev, showCategory = 50)
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.treeMap-GO-BP_developmental.pdf", height = 10, width = 20)
treeplot(trim_bp_dev, showCategory = 5, layout = "circular", offset_tiplab = rel(0.4))
dev.off()
```
```{r}
#anterior
VlnPlot(emb.GFPpooled_v2.finalfiltClusters, features = c('C14C6.5', 'cpr-1'), raster=F)

#central
VlnPlot(emb.GFPpooled_v2.finalfiltClusters, features = c('endu-2', 'clec-56'), raster=F)

#posterior
VlnPlot(emb.GFPpooled_v2.finalfiltClusters, features = c('pbo-4'), raster=F)


clusters_to_use2 <- as.character(c(1, 3:9, 11:13))
regional.clusters.list <- cluster_gene_list[names(cluster_gene_list) %in% clusters_to_use2]


go_compare_bp_region <- compareCluster(geneCluster = regional.clusters.list, 
                             fun = "enrichGO", 
                             OrgDb = org.Ce.eg.db, 
                             ont = "BP",  # "BP"、"MF" or "CC"
                             pAdjustMethod = "BH",
                             pvalueCutoff = 0.05,
                             qvalueCutoff = 0.05)

bp_region <- simplify(go_compare_bp_region, cutoff=1, by="p.adjust", select_fun=min)

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.dotPlot-GO-BP_region.pdf", height = 10, width = 20)
cluster.p1 <- dotplot(bp_region, showCategory = 1,
              title = "GO Enrichment (Biological Process)")
cluster.p1 + theme(
  axis.text.y = element_text(size = 15),
  axis.text.x = element_text(size = 15),
  legend.text = element_text(size = 15)
  )
dev.off()


trim_bp_region <- pairwise_termsim(bp_region, showCategory = 50)
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.treeMap-GO-BP_region.pdf", height = 10, width = 20)
treeplot(trim_bp_region, showCategory = 5, layout = "circular", offset_tiplab = rel(0.4))
dev.off()
```

```{r}
# simplify() in clusterprofiler and GOSemSim
#BiocManager::install("GOSemSim")
#browseVignettes("GOSemSim")
# https://yulab-smu.top/biomedical-knowledge-mining-book/

#If you use [clusterProfiler](https://www.bioconductor.org/packages/clusterProfiler) in published research, please cite:


#__*G Yu*__, LG Wang, Y Han, QY He. clusterProfiler: an R package for comparing biological themes among gene clusters. **_OMICS: A Journal of Integrative Biology_** 2012, 16(5):284-287. doi:[10.1089/omi.2011.0118](http://dx.doi.org/10.1089/omi.2011.0118)

# bp1 <- simplify(go_compare_bp, cutoff=1, by="p.adjust", select_fun=min)
# bp0.3 <- simplify(go_compare_bp, cutoff=0.3, by="p.adjust", select_fun=min)
# 
# cluster.p1 <- dotplot(bp1, showCategory = 1,
#               title = "GO Enrichment (Biological Process)")
# cluster.p1 + theme(
#   axis.text.y = element_text(size = 15),
#   axis.text.x = element_text(size = 15),
#   legend.text = element_text(size = 15))
```



#calculate gene level variance in expression across clusters
```{r}
# average expression per cluster. Rows = genes, Columns = clusters
avg_expr <- AverageExpression(emb.GFPpooled_v2.finalfiltClusters, return.seurat = FALSE)$RNA

# variance of each gene across clusters
gene_variances <- apply(avg_expr, 1, var)

threshold <- 0.1

# select top variable genes (e.g., top 50)
#top_genes <- names(sort(gene_variances, decreasing = TRUE))[1:500]
#top_genes <- names(sort(gene_variances, decreasing = TRUE))[1:50]

top_genes <- names(gene_variances[gene_variances > threshold])
top_genes <- top_genes[order(gene_variances[top_genes], decreasing = TRUE)]


# extract the expression values for top genes
heatmap_data <- avg_expr[top_genes, ]
num_genes <- nrow(heatmap_data)
print(num_genes)

# scale genes (z-score across clusters)
scaled_data <- t(scale(t(as.matrix(heatmap_data))))

# plot heatmap
#install.packages('pheatmap')
#library(pheatmap)

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.finalfiltClusters.varianceHM.pdf", height = 10, width = 20)
pheatmap(scaled_data,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         show_rownames = TRUE,
         show_colnames = TRUE,
         fontsize_row = 8,
         main = "Top Variable Genes Across Clusters")
dev.off()
```




----



# Perform gene ontology
```{r}
library(reticulate)
py_config()
# to modify the python to use in R, nano ~/.Renviron. just uncomment the right path and comment out the other. Will need to restart the Rsession before implimenting. 
use_condaenv("base")

tea <- import("tissue_enrichment_analysis")
tissue_df <- tea$fetch_dictionary("tissue")
phenotype_df <- tea$fetch_dictionary("phenotype")
go_df <- tea$fetch_dictionary("go")
```

```{r}
emb.GFPpooled_v2.clean.markers_1 <- emb.GFPpooled_v2.clean.markers %>% left_join(genes.df, by = c("gene" = "external_gene_id")) 
view(emb.GFPpooled_v2.clean.markers_1)


emb.GFPpooled_v2.clean.markers_1 <- emb.GFPpooled_v2.clean.markers_1 %>% rename(WBGeneID = wbps_gene_id)
#emb.GFPpooled_v2.clean.markers_1 <- emb.GFPpooled_v2.clean.markers_1 %>% rename(wbid = WBGeneID)
view(emb.GFPpooled_v2.clean.markers_1)


emb.ALLpooled_v2.markers_1 <- emb.ALLpooled_v2.markers %>% left_join(genes.df, by = c("gene" = "external_gene_id")) 
view(emb.ALLpooled_v2.markers_1)


emb.ALLpooled_v2.markers_1 <- emb.ALLpooled_v2.markers_1 %>% rename(WBGeneID = wbps_gene_id)
#emb.ALLpooled_v2.markers_1 <- emb.ALLpooled_v2.markers_1 %>% rename(wbid = WBGeneID)
view(emb.ALLpooled_v2.markers_1)
```

```{r}
# set up go_df to represent only our background genes 
view(go_df)

cluster0 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 0)
view(cluster0)
cluster1 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 1)
view(cluster1)
cluster2 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 2)
view(cluster2)
cluster3 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 3)
view(cluster3)
cluster4 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 4)
view(cluster4)
cluster5 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 5)
view(cluster5)
cluster6 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 6)
view(cluster6)
cluster7 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 7)
view(cluster7)
cluster8 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 8)
view(cluster8)
cluster9 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 9)
view(cluster9)
cluster10 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 10)
view(cluster10)
cluster11 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 11)
view(cluster11)
cluster12 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 12)
view(cluster12)
cluster13 <- emb.GFPpooled_v2.clean.markers_1 %>% filter(cluster == 13)
view(cluster13)



go_df_background <- go_df %>% filter(wbid %in% emb.GFPpooled_v2.clean.markers_1$WBGeneID)
view(go_df_background)

go_df_background_0 <- go_df %>% filter(wbid %in% cluster0$WBGeneID)
view(go_df_background_0)
go_df_background_1 <- go_df %>% filter(wbid %in% cluster1$WBGeneID)
view(go_df_background_1)
go_df_background_2 <- go_df %>% filter(wbid %in% cluster2$WBGeneID)
view(go_df_background_2)
go_df_background_3 <- go_df %>% filter(wbid %in% cluster3$WBGeneID)
view(go_df_background_3)
go_df_background_4 <- go_df %>% filter(wbid %in% cluster4$WBGeneID)
view(go_df_background_4)
go_df_background_5 <- go_df %>% filter(wbid %in% cluster5$WBGeneID)
view(go_df_background_5)
go_df_background_6 <- go_df %>% filter(wbid %in% cluster6$WBGeneID)
view(go_df_background_6)
go_df_background_7 <- go_df %>% filter(wbid %in% cluster7$WBGeneID)
view(go_df_background_7)
go_df_background_8 <- go_df %>% filter(wbid %in% cluster8$WBGeneID)
view(go_df_background_8)
go_df_background_9 <- go_df %>% filter(wbid %in% cluster9$WBGeneID)
view(go_df_background_9)
go_df_background_10 <- go_df %>% filter(wbid %in% cluster10$WBGeneID)
view(go_df_background_10)
go_df_background_11 <- go_df %>% filter(wbid %in% cluster11$WBGeneID)
view(go_df_background_11)
go_df_background_12 <- go_df %>% filter(wbid %in% cluster12$WBGeneID)
view(go_df_background_12)
go_df_background_13 <- go_df %>% filter(wbid %in% cluster13$WBGeneID)
view(go_df_background_13)
```


```{r}
clusters <- emb.GFPpooled_v2.clean.markers_1$cluster

clusters <- cluster0$cluster
clusters <- cluster1$cluster
clusters <- cluster2$cluster
clusters <- cluster3$cluster
clusters <- cluster4$cluster
clusters <- cluster5$cluster
clusters <- cluster6$cluster
clusters <- cluster7$cluster
clusters <- cluster8$cluster
clusters <- cluster9$cluster
clusters <- cluster10$cluster
clusters <- cluster11$cluster
clusters <- cluster12$cluster
clusters <- cluster13$cluster
```
```{r}
my_tea_analysis <- function(input_df, tea_dict){
  tea_df <- data.frame()
  for (i in clusters){
  tea_set <- tea$enrichment_analysis(
    (input_df %>% 
       filter(cluster == i))$WBGeneID, 
    tissue_df = tea_dict 
  )
  if(nrow(tea_set) == 0){
    next
  } else {
  tea_df <- bind_rows(tea_df, data.frame(tea_set, cluster = i))
  }
}
tea_df
}

reorder_within <- function(x, by, within, fun = mean, sep = "___", ...) {
    new_x <- paste(x, within, sep = sep)
    stats::reorder(new_x, by, FUN = fun)
}

scale_x_reordered <- function(..., sep = "___") {
    reg <- paste0(sep, ".+$")
    ggplot2::scale_x_discrete(labels = function(x) gsub(reg, "", x), ...)
}

my_ontology_plot <- function(input_df, xlabel){
  input_df %>%
  filter(Q.value < 0.001,  Observed > 10) %>% 
  ggplot(aes(x = reorder_within(Term, -log10(Q.value), cluster), y = -log10(Q.value))) +
  geom_point(aes(size = Observed)) +
  coord_flip() +
  scale_x_reordered() +
  facet_wrap(cluster~., ncol = 3, scales = "free_y") +
  theme_bw() +
  xlab(xlabel) +
  guides(size = guide_legend(title = "# genes")) +
  scale_size_continuous(breaks = c(10,20,100,200,300))
}
```

```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_0_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster0 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_0), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_0.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster0 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_1_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster1 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_1), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_1.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster1 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
# pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_2_background.pdf", height = 10, width = 20)
# my_ontology_plot(my_tea_analysis(cluster2 %>% filter(p_val_adj < 0.01, avg_log2FC > 0.5), go_df_background_2), "Gene Ontology") + theme(text = element_text(size = 30))
# dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_2.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster2 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_3_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster3 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_3), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_3.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster3 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_4_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster4 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df_background_4), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_4.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster4 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
# pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_5_background.pdf", height = 10, width = 20)
# my_ontology_plot(my_tea_analysis(cluster5 %>% filter(p_val_adj < 0.01, avg_log2FC > 0.5), go_df_background_5), "Gene Ontology") + theme(text = element_text(size = 30))
# dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_5.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster5 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_6_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster6 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_6), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_6.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster6 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_7_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster7 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_7), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_7.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster7 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
# pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_8_background.pdf", height = 10, width = 20)
# my_ontology_plot(my_tea_analysis(cluster8 %>% filter(p_val_adj < 0.01, avg_log2FC > 0.5), go_df_background_8), "Gene Ontology") + theme(text = element_text(size = 30))
# dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_8.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster8 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
# pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_9_background.pdf", height = 10, width = 20)
# my_ontology_plot(my_tea_analysis(cluster9 %>% filter(p_val_adj < 0.05, avg_log2FC > 0.5), go_df_background_9), "Gene Ontology") + theme(text = element_text(size = 30))
# dev.off()
# 
# pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_9.pdf", height = 10, width = 20)
# my_ontology_plot(my_tea_analysis(cluster9 %>% filter(p_val_adj < 0.01, avg_log2FC > 0.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
# dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_10_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster10 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_10), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_10.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster10 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_11_background.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster11 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_11), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_11.pdf", height = 10, width = 20)
my_ontology_plot(my_tea_analysis(cluster11 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_12_background.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(cluster12 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_12), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_12.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(cluster12 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```
```{r}
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_13_background.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(cluster13 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df_background_13), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_13.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(cluster13 %>% filter(p_val_adj < 0.01, avg_log2FC > 1.5), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```

```{r}
# not wide enough output, the figures are smooshed 
pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G_background.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(emb.GFPpooled_v2.clean.markers_1 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df_background), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()

pdf("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.clean.GO_G.pdf", height = 10, width = 25)
my_ontology_plot(my_tea_analysis(emb.GFPpooled_v2.clean.markers_1 %>% filter(p_val_adj < 0.01, avg_log2FC > 1), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
dev.off()
```














# plot genes of interest
From John Murray dataset 
    - intestine_anterior: ZC204.12, cpr-1, ceh-37
    - intestine_middle_and_posterior: irg-7, pal-1, cpr-1, ceh-37
    - intestine_far_posterior: irg-7, faah-1, pbo-4, psa-3
```{r}
# # top marker gene for each cluster
# FeaturePlot(emb.GFPpooled, pt.size = 0.1,
#             features = (emb.GFPpooled.markers %>% group_by(cluster) %>% slice_max(n = 1, order_by = avg_log2FC))$gene)
```

```{r}
# # genes from murray data
# # intestine_anterior
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('ZC204.12', 'cpr-1', 'ceh-37'), raster=F, ncol = 1) +
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.Murray-Anterior.png") 
# 
# # intestine_middle_and_posterior
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('irg-7', 'pal-1', 'cpr-1', 'ceh-37'), raster=F, ncol = 1) + 
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.Murray-Mid.png")
# 
# # intestine_far_posterior
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('faah-1', 'pbo-4', 'psa-3'), raster=F, ncol = 1) + 
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.Murray-Posterior.png")
```

```{r}
# # marker genes we FISHed for
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('C14C6.5', 'clec-56', 'pbo-4'), raster=F, ncol = 1) + 
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.smiFISH-genes.png")
```

-------------------------------NOT USING RIGHT NOW-----------------------
# Remove contamination clusters
contamination clusters = 6, 12, 20
```{r}
emb.GFPpooled_v2.specificClusters <- RunUMAP(subset(emb.GFPpooled_v2, idents = c('6','12', '20'), invert = TRUE), dims = 1:20)
```
# now rerun PCA and re-lcuster 
```{r}
emb.GFPpooled_v2.specificClusters <- RunPCA(emb.GFPpooled_v2.specificClusters, features = VariableFeatures(object = emb.GFPpooled_v2.specificClusters))

DimPlot(emb.GFPpooled_v2.specificClusters, reduction = "pca")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.DimPlot.png")

ElbowPlot(emb.GFPpooled_v2.specificClusters)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.ElbowPlot.png")
```
```{r}
# Choose the number of PCs to use for re-clustering 
emb.GFPpooled_v2.specificClusters <- FindNeighbors(emb.GFPpooled_v2.specificClusters, dims = 1:7)

# check new clusters with Clustree
emb.GFPpooled_v2.specificClusters.recluster <- FindClusters(
  object = emb.GFPpooled_v2.specificClusters,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:7,
  save.SNN = TRUE)

clustree(emb.GFPpooled_v2.specificClusters.recluster, prefix = "RNA_snn_res.")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.Clustree.png")

emb.GFPpooled_v2.specificClusters.recluster <- FindClusters(emb.GFPpooled_v2.specificClusters, resolution = 1.2)

emb.GFPpooled_v2.specificClusters.recluster <- RunUMAP(emb.GFPpooled_v2.specificClusters.recluster, dims = 1:7)

DimPlot(emb.GFPpooled_v2.specificClusters.recluster, reduction = "umap", group.by = c("rep_group", "seurat_clusters"), pt.size = 1) + theme(legend.text = element_text(size = 15))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.UMAP.png") 

DimPlot(emb.GFPpooled_v2.specificClusters.recluster, reduction = "umap", split.by = c("rep_group"), pt.size = 1) + theme(legend.text = element_text(size = 15))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.UMAP.rep.png") 
```

# Find new marker genes
```{r}
#find markers for every cluster compared to all remaining cells
emb.GFPpooled_v2.specificClusters.recluster.markers <- FindAllMarkers(emb.GFPpooled_v2.specificClusters.recluster, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

emb.GFPpooled_v2.specificClusters.recluster.markers %>% 
  group_by(cluster) %>%
  slice_max(n = 2, order_by = avg_log2FC)

write.csv(emb.GFPpooled_v2.specificClusters.recluster.markers,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.markers.csv", row.names = TRUE)
```


# Validate clusters 
```{r}
emb.GFPpooled_v2.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=1, wt=avg_log2FC) -> top1_reclust

DoHeatmap(emb.GFPpooled_v2.specificClusters.recluster, features = top1_reclust$gene,raster=F) + theme(text = element_text(size = 20))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.HeatMap-top1.png") 

DoHeatmap(emb.GFPpooled_v2.specificClusters.recluster, features = c(top1_reclust$gene, "clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F) + theme(text = element_text(size = 20))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.HeatMap-top1.fish.png") 


# intestine marker genes
FeaturePlot(emb.GFPpooled_v2.specificClusters.recluster, features = c("elt-2","elt-7", 'ges-1'),raster=F, ncol = 2)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.FeaturePlot-PostCtrls.png")

# Contamination marker genes: germline (glh-1, chs-1), muscle (myo-2, myo-3), neuron(hlh-2, rab-3)  
FeaturePlot(emb.GFPpooled_v2.specificClusters.recluster, features = c("glh-1","chs-1", "myo-2", "myo-3", "hlh-2", "rab-3"), raster=F, ncol = 2)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.FeaturePlot-NegCtrls.png")


# FISH
FeaturePlot(emb.GFPpooled_v2.specificClusters.recluster, features = c("clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F, ncol = 3)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.FeaturePlot-FISH.png")
```


# Perform gene ontology
```{r}
library(reticulate)
py_config()
# to modify the python to use in R, nano ~/.Renviron. just uncomment the right path and comment out the other. Will need to restart the Rsession before implimenting. 
use_condaenv("base")

tea <- import("tissue_enrichment_analysis")
tissue_df <- tea$fetch_dictionary("tissue")
phenotype_df <- tea$fetch_dictionary("phenotype")
go_df <- tea$fetch_dictionary("go")
```

```{r}
emb.GFPpooled.specificClusters.recluster.markers <- emb.GFPpooled.specificClusters.recluster.markers %>% left_join(genes.df, by = c("gene" = "external_gene_id")) 

emb.GFPpooled.specificClusters.recluster.markers <- emb.GFPpooled.specificClusters.recluster.markers %>% rename(WBGeneID = wbps_gene_id)
```

```{r}
clusters <- unique(emb.GFPpooled.specificClusters.recluster.markers$cluster)

my_tea_analysis <- function(input_df, tea_dict){
  tea_df <- data.frame()
  for (i in clusters){
  tea_set <- tea$enrichment_analysis(
    (input_df %>% 
       filter(cluster == i))$WBGeneID, 
    tissue_df = tea_dict 
    # %>% 
    #   filter(wbid %in% (input_df %>% 
    #                       filter(cluster %in% clusters))$WBGeneID)
  )
  if(nrow(tea_set) == 0){
    next
  } else {
  tea_df <- bind_rows(tea_df, data.frame(tea_set, cluster = i))
  }
}
tea_df
}

reorder_within <- function(x, by, within, fun = mean, sep = "___", ...) {
    new_x <- paste(x, within, sep = sep)
    stats::reorder(new_x, by, FUN = fun)
}

scale_x_reordered <- function(..., sep = "___") {
    reg <- paste0(sep, ".+$")
    ggplot2::scale_x_discrete(labels = function(x) gsub(reg, "", x), ...)
}

my_ontology_plot <- function(input_df, xlabel){
  input_df %>%
  filter(Q.value < 0.001,  Observed > 50) %>% 
  ggplot(aes(x = reorder_within(Term, -log10(Q.value), cluster), y = -log10(Q.value))) +
  geom_point(aes(size = Observed)) +
  coord_flip() +
  scale_x_reordered() +
  facet_grid(cluster~., scales = "free_y") +
  theme_bw() +
  xlab(xlabel) +
  guides(size = guide_legend(title = "# genes")) +
  scale_size_continuous(breaks = c(20,100,200))
}
```

```{r fig.height=15, fig.width=5}
my_ontology_plot(my_tea_analysis(emb.GFPpooled.specificClusters.recluster.markers %>% filter(p_val_adj < 0.05, avg_log2FC > 1), tissue_df), "Tissue Ontology")

ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.GO_T.png")
```

```{r fig.height=15, fig.width=5}
my_ontology_plot(my_tea_analysis(emb.GFPpooled.specificClusters.recluster.markers %>% filter(p_val_adj < 0.05, avg_log2FC > 1.01), go_df), "Gene Ontology") + theme(text = element_text(size = 15))

ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.GO_G.png")
```


# Pull out new cluster marker genes 
```{r}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=4, wt=avg_log2FC) -> top4

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top4$gene,raster=F)

ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top4.png")
```


# Pull out new cluster specific CLECs 
```{r}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(grepl("clec*",gene), p_val_adj < .01) %>% top_n(n=2, wt=avg_log2FC) -> top2clecs

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top2clecs$gene,raster=F)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top2clecs.png")
```


# Pull out cluster specific SPPs 
```{r fig.height=4, fig.width=7}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(grepl("^spp",gene), p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10spps

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top10spps$gene,raster=F)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top10spp.png")
```

# Pull out cluster specific IRGs 
```{r fig.height=4, fig.width=7}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(grepl("^irg",gene), p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10irgs

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top10irgs$gene,raster=F)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top10irg.png")
```



# plot genes of interest
From John Murray dataset 
    - intestine_anterior: ZC204.12, cpr-1, ceh-37
    - intestine_middle_and_posterior: irg-7, pal-1, cpr-1, ceh-37
    - intestine_far_posterior: irg-7, faah-1, pbo-4, psa-3

```{r}
# top marker gene for each cluster
FeaturePlot(emb.GFPpooled.specificClusters.recluster, pt.size = 0.1,
            features = (emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% slice_max(n = 1, order_by = avg_log2FC))$gene)
```

```{r}
# genes from murray data
# intestine_anterior
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('ZC204.12', 'cpr-1', 'ceh-37'), raster=F, ncol = 2)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.Murray-Anterior.png") 

# intestine_middle_and_posterior
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('irg-7', 'pal-1', 'cpr-1', 'ceh-37'), raster=F, ncol = 2)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.Murray-Mid.png")

# intestine_far_posterior
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('faah-1', 'pbo-4', 'psa-3'), raster=F, ncol = 2)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.Murray-Posterior.png")
```



# Assign cell type identity to clusters 
```
new.cluster.ids <- c("Naive CD4 T", "CD14+ Mono", "Memory CD4 T", "B", "CD8 T", "FCGR3A+ Mono",
    "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

