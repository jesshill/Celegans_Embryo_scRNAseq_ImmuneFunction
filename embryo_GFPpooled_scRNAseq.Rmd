---
title: "embryo_intestine_scRNAseq"
author: "Jessica Hill"
date: "9/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---

# Install packages
```{r}
#install.packages('Seurat')
#packageVersion('Seurat') # 5.0.1
#install.packages('Matrix')
#install.packages("hdf5r")
#install.packages("clustree")
#install.packages("tidyverse")
#install.packages("patchwork")
#install.packages("remotes")
#install.packages("R.utils")

#remotes::install_github('satijalab/seurat-wrappers')


#if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install(version = "3.19")

#BiocManager::install("biomaRt")

#BiocManager::install('multtest')
#install.packages('metap')

#install.packages('devtools')
#devtools::install_github('immunogenomics/presto')
```

# Load packages
```{r echo=FALSE}
library(biomaRt)
library(Seurat)
library(SeuratWrappers)
library(ggplot2)
library(tidyverse)
library(patchwork)
library(clustree)
library(metap)
library(presto)
```

---
count matrix
QC and filtering
Normalization
Linear dimensionality reduction (PCA)
Scale data
Identify highly variable genes
Clustering
Non-linear dimensional reduction (UMAP/t-SNE)
---

# Load the data
```{r}
#emb.GFPpooled_v1.data <- Read10X_h5("./cellranger/all_GFP_v1/filtered_feature_bc_matrix.h5")

emb.GFPpooled_v2.data <- Read10X_h5("./cellranger/all_GFP_v2/filtered_feature_bc_matrix.h5")

emb.ALLpooled_v2.data <- Read10X_h5("./cellranger/all_pooled_v2/filtered_feature_bc_matrix.h5")
```


Get filternames from https://parasite.wormbase.org/biomart/martview
```{r}
mart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)

genes.df <- getBM(mart = mart, 
      filters = c("species_id_1010", "gene_name"),
      value = list("caelegprjna13758", rownames(emb.ALLpooled_v2.data)),
      attributes = c('wbps_gene_id','external_gene_id', 'chromosome_name'))

mitoList = genes.df[genes.df$chromosome_name == 'MtDNA', 'external_gene_id']
genes.df$chromosome_name = NULL

c(nrow(genes.df), nrow(emb.ALLpooled_v2.data))

# there are genes missing
nrow(emb.ALLpooled_v2.data)-nrow(genes.df)
```
```{r}
mart <- useMart("parasite_mart", dataset = "wbps_gene", host = "https://parasite.wormbase.org", port = 443)

genes1.df <- getBM(mart = mart, 
      filters = c("species_id_1010", "gene_name"),
      value = list("caelegprjna13758", rownames(emb.GFPpooled_v2.data)),
      attributes = c('wbps_gene_id','external_gene_id', 'chromosome_name'))

mitoList = genes1.df[genes1.df$chromosome_name == 'MtDNA', 'external_gene_id']
genes1.df$chromosome_name = NULL

c(nrow(genes1.df), nrow(emb.GFPpooled_v2.data))

# there are genes missing
nrow(emb.GFPpooled_v2.data)-nrow(genes1.df)
```



There are `r nrow(emb.GFPpooled.data)-nrow(genes.df)` genes that are now dead, remove them from the input matrix.
```{r}
emb.ALLpooled_v2.data.filt <- emb.ALLpooled_v2.data[rownames(emb.ALLpooled_v2.data) %in% genes.df$external_gene_id,]

# The two data structures do not have the same order of WBGeneIDs
identical(rownames(emb.ALLpooled_v2.data.filt), genes.df$external_gene_id)

# Use match to make sure they are in the same order
identical(rownames(emb.ALLpooled_v2.data.filt),
          genes.df[match(rownames(emb.ALLpooled_v2.data.filt), genes.df$external_gene_id),]$external_gene_id)

# now replace the WBGeneIDs with gene names
#rownames(emb.GFPpooled.data.filt) <- genes.df[
#  match(rownames(emb.GFPpooled.data.filt),
#        genes.df$wbps_gene_id)
#  ,]$external_gene_id

# are there NAs?
sum(!is.na(rownames(emb.ALLpooled_v2.data.filt)))

head(emb.ALLpooled_v2.data.filt)
```
```{r}
emb.GFPpooled_v2.data.filt <- emb.GFPpooled_v2.data[rownames(emb.GFPpooled_v2.data) %in% genes1.df$external_gene_id,]

# The two data structures do not have the same order of WBGeneIDs
identical(rownames(emb.GFPpooled_v2.data.filt), genes1.df$external_gene_id)

# Use match to make sure they are in the same order
identical(rownames(emb.GFPpooled_v2.data.filt),
          genes1.df[match(rownames(emb.GFPpooled_v2.data.filt), genes1.df$external_gene_id),]$external_gene_id)

# now replace the WBGeneIDs with gene names
#rownames(emb.GFPpooled.data.filt) <- genes.df[
#  match(rownames(emb.GFPpooled.data.filt),
#        genes.df$wbps_gene_id)
#  ,]$external_gene_id

# are there NAs?
sum(!is.na(rownames(emb.GFPpooled_v2.data.filt)))

head(emb.GFPpooled_v2.data.filt)
```


```{r}
# extract the cell codes (barcode info with the trailing integer which signifies the order of the samples in the aggregation step)
cellcodes <- as.data.frame(emb.ALLpooled_v2.data.filt@Dimnames[[2]])
colnames(cellcodes) <- "barcodes"
rownames(cellcodes) <- cellcodes$barcodes
cellcodes$rep_group <- ifelse(grepl("-1$", cellcodes$barcodes), "Rep_1", ifelse(grepl("-2$", cellcodes$barcodes), "Rep_2", ifelse(grepl("-3$", cellcodes$barcodes), "Rep_3", "Rep_4")))
view(cellcodes)
```
```{r}
cellcodes_1 <- as.data.frame(emb.GFPpooled_v2.data.filt@Dimnames[[2]])
colnames(cellcodes_1) <- "barcodes"
rownames(cellcodes_1) <- cellcodes_1$barcodes 
cellcodes_1$rep_group <- ifelse(grepl("-1$", cellcodes_1$barcodes), "Rep_1", ifelse(grepl("-2$", cellcodes_1$barcodes), "Rep_2", ifelse(grepl("-3$", cellcodes_1$barcodes), "Rep_3", "Rep_4")))
view(cellcodes_1)
```



# Set up the Seurat object
# Initialize the Seurat object with the raw (non-normalized data).
```{r}
emb.ALLpooled_v2 <- CreateSeuratObject(counts = emb.ALLpooled_v2.data.filt, project = "emb.ALLpooled_v2", min.cells = 3, min.features = 200, meta.data = cellcodes)

view(emb.ALLpooled_v2@meta.data)
```
```{r}
emb.GFPpooled_v2 <- CreateSeuratObject(counts = emb.GFPpooled_v2.data.filt, project = "emb.GFPpooled_v2", min.cells = 3, min.features = 200, meta.data = cellcodes_1)

view(emb.GFPpooled_v2@meta.data)
```


```{r}
emb.ALLpooled_v2[["RNA"]] <- split(emb.ALLpooled_v2[["RNA"]], f = emb.ALLpooled_v2$rep_group)
emb.ALLpooled_v2
```
```{r}
emb.GFPpooled_v2[["RNA"]] <- split(emb.GFPpooled_v2[["RNA"]], f = emb.GFPpooled_v2$rep_group)
emb.GFPpooled_v2
```


```{r}
length(unique(genes.df$wbps_gene_id))
length(unique(rownames(emb.ALLpooled_v2)))
rownames(emb.ALLpooled_v2)[!(rownames(emb.ALLpooled_v2) %in% genes.df$external_gene_id)]
```
```{r}
length(unique(genes1.df$wbps_gene_id))
length(unique(rownames(emb.GFPpooled_v2)))
rownames(emb.GFPpooled_v2)[!(rownames(emb.GFPpooled_v2) %in% genes1.df$external_gene_id)]
```


# Quality control metrics
- `nFeature_RNA` is the number of genes detected in each cell. 
- `nCount_RNA` is the total number of molecules detected within a cell (AKA total UMIs per cell)
- Low `nFeature_RNA` indicates that the cell may be dead or dying or an empty droplet
- High `nCount_RNA` and/or `nFeature_RNA` indicates that the "cell" may in fact be a doublet (or multiplet)

```{r}
# show QC metrics for the first 5 cells 
view(emb.ALLpooled_v2@meta.data)
head(emb.ALLpooled_v2@meta.data, 5)

view(emb.GFPpooled_v2@meta.data)
head(emb.GFPpooled_v2@meta.data, 5)
```

Mitochondrial genome percentage 
```{r}
mitoIndices = which(rownames(emb.ALLpooled_v2) %in% mitoList)
emb.ALLpooled_v2[["percent.mt"]] <- PercentageFeatureSet(emb.ALLpooled_v2, features = mitoIndices)
```
```{r}
mitoIndices_1 = which(rownames(emb.GFPpooled_v2) %in% mitoList)
emb.GFPpooled_v2[["percent.mt"]] <- PercentageFeatureSet(emb.GFPpooled_v2, features = mitoIndices_1)
```

Visualize QC metrics as a violin plot
```{r}
VlnPlot(emb.ALLpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
ggsave("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.VlnPlot.png")


VlnPlot(emb.GFPpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VlnPlot.png")
```

FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
```{r}
plot1 <- FeatureScatter(emb.ALLpooled_v2, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.ALLpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
ggsave("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeatureScatter.png")
```
```{r}
plot1 <- FeatureScatter(emb.GFPpooled_v2, feature1 = "nCount_RNA", feature2 = "percent.mt") + geom_hline(yintercept = 50)
plot2 <- FeatureScatter(emb.GFPpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeatureScatter.png")
```


Filter based on features.
cells being filtered due to mito percent: 
```{r}
sum(emb.ALLpooled_v2$percent.mt > 50)/ length(emb.ALLpooled_v2$percent.mt)
emb.ALLpooled_v2 <- subset(emb.ALLpooled_v2, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)
```
```{r}
sum(emb.GFPpooled_v2$percent.mt > 50)/ length(emb.GFPpooled_v2$percent.mt)
emb.GFPpooled_v2 <- subset(emb.GFPpooled_v2, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & nCount_RNA < 50000 & percent.mt < 50)
```


Visualize after filtering
```{r}
VlnPlot(emb.ALLpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"))
ggsave("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.VlnPlot.filt.png")

FeatureScatter(emb.ALLpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
ggsave("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.FeatureScatter.filt.png")
```
```{r}
VlnPlot(emb.GFPpooled_v2, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VlnPlot.filt.png")

FeatureScatter(emb.GFPpooled_v2, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeatureScatter.filt.png")
```

```{r}
view(emb.ALLpooled_v2@meta.data)
hist(emb.ALLpooled_v2$nFeature_RNA)
hist(emb.ALLpooled_v2$nCount_RNA)

view(emb.ALLpooled_v2@assays$RNA$counts)
exp_matrix <- as.matrix(emb.ALLpooled_v2@assays$RNA$counts)
gene_express_per_cell <- rowSums(exp_matrix)
genes_express_only_once <- sum(gene_express_per_cell==1)
```
```{r}
view(emb.GFPpooled_v2@meta.data)
hist(emb.GFPpooled_v2$nFeature_RNA)
hist(emb.GFPpooled_v2$nCount_RNA)

view(emb.GFPpooled_v2@assays$RNA$counts)
exp_matrix1 <- as.matrix(emb.GFPpooled_v2@assays$RNA$counts)
gene_express_per_cell1 <- rowSums(exp_matrix1)
genes_express_only_once1 <- sum(gene_express_per_cell1==1)
```

# Normalize the data
After removing unwanted cells from the dataset, we next normalize the data. 
By default, we employ a global-scaling normalization method "LogNormalize" that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 is the default), and log-transforms the result. 

Normalized values are stored in emb.GFPpooled[["RNA]]@data

```{r}
emb.ALLpooled_v2 <- NormalizeData(emb.ALLpooled_v2, normalization.method = "LogNormalize", scale.factor = 10000)
```
```{r}
emb.GFPpooled_v2 <- NormalizeData(emb.GFPpooled_v2, normalization.method = "LogNormalize", scale.factor = 10000)
```


# Feature selection
Identify highly variable features to focus on in downstream analysis
```{r}
emb.ALLpooled_v2 <- FindVariableFeatures(emb.ALLpooled_v2, selection.method = "vst", nfeatures = 2000)

emb.GFPpooled_v2 <- FindVariableFeatures(emb.GFPpooled_v2, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10_all <- head(VariableFeatures(emb.ALLpooled_v2), 10)
top10_GFP <- head(VariableFeatures(emb.GFPpooled_v2), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(emb.ALLpooled_v2)
LabelPoints(plot = plot1, points = top10_all, repel = TRUE)
ggsave("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.VarFeatures.png")

plot1 <- VariableFeaturePlot(emb.GFPpooled_v2)
LabelPoints(plot = plot1, points = top10_GFP, repel = TRUE)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.VarFeatures.png")
```


# Scaling the data
Apply a linear transformation ("scaling") prior to dimensional reduction, PCA. 
Shifts the expression of each gene, so that the mean expression across cells is 0. 
Scales the expression of each gene, so that the variance across cells is 1. 
This gives equal weight in downstream analysis, so that highly expressed genes dont dominate. 
```{r}
all.genes <- rownames(emb.ALLpooled_v2)
emb.ALLpooled_v2 <- ScaleData(emb.ALLpooled_v2, features = all.genes)


all.genes_1 <- rownames(emb.GFPpooled_v2)
emb.GFPpooled_v2 <- ScaleData(emb.GFPpooled_v2, features = all.genes_1)
```


# Linear dimensional reduction 
perform PCA on the scaled data. 
By default, only the previously determined vairable features are used as input. 
```{r}
emb.ALLpooled_v2 <- RunPCA(emb.ALLpooled_v2, features = VariableFeatures(object = emb.ALLpooled_v2))


emb.GFPpooled_v2 <- RunPCA(emb.GFPpooled_v2, features = VariableFeatures(object = emb.GFPpooled_v2))
```

Examine and visualize PCA results a few different ways
```{r}
print(emb.ALLpooled_v2[["pca"]], dims = 1:5, nfeatures = 5)

print(emb.GFPpooled_v2[["pca"]], dims = 1:5, nfeatures = 5)
```

```{r}
# top genes associated with reduction components
VizDimLoadings(emb.ALLpooled_v2, dims = 1:2, reduction = "pca")
ggsave("./Seurat_output/all_pooled_v2/emb.ALLpooled_v2.DimLoadings.png")


VizDimLoadings(emb.GFPpooled_v2, dims = 1:2, reduction = "pca")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.DimLoadings.png")
```

```{r}
DimPlot(emb.GFPpooled_v1, reduction = "pca")
ggsave("./Seurat_output/all_GFP_v1/emb.GFPpooled_v1.DimPlot.png")

DimPlot(emb.GFPpooled_v2, reduction = "pca")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.DimPlot.png")
```

```{r}
DimHeatmap(emb.GFPpooled_v1, dims = 1, cells = 500, balanced = TRUE)
ggsave("./Seurat_output/all_GFP_v1/emb.GFPpooled_v1.HeatMap1.png")

DimHeatmap(emb.GFPpooled_v2, dims = 1, cells = 500, balanced = TRUE)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.HeatMap1.png")
```

```{r}
DimHeatmap(emb.GFPpooled_v1, dims = 1:6, cells = 500, balanced = TRUE)
ggsave("./Seurat_output/all_GFP_v1/emb.GFPpooled_v1.HeatMap1-6.png")

DimHeatmap(emb.GFPpooled_v2, dims = 1:6, cells = 500, balanced = TRUE)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.HeatMap1-6.png")
```


# Determine dataset dimensionality
To overcome the extensive technical noise in any single feature for scRNA-seq data, Seurat clusters cells based on their PCA scores, with each PC essentially representing a ‘metafeature’ that combines information across a correlated feature set. The top principal components therefore represent a robust compression of the dataset. However, how many components should we choose to include? 

Seurat implements a resampling test inspired by the JackStraw procedure. We randomly permute a subset of the data (1% by default) and rerun PCA, constructing a ‘null distribution’ of feature scores, and repeat this procedure. We identify ‘significant’ PCs as those who have a strong enrichment of low p-value features
```{r}
emb.GFPpooled_v1 <- JackStraw(emb.GFPpooled_v1, num.replicate = 100)
emb.GFPpooled_v1 <- ScoreJackStraw(emb.GFPpooled_v1, dims = 1:20)


emb.GFPpooled_v2 <- JackStraw(emb.GFPpooled_v2, num.replicate = 100)
emb.GFPpooled_v2 <- ScoreJackStraw(emb.GFPpooled_v2, dims = 1:20)
```

The JackStrawPlot() function provides a visualization tool for comparing the distribution of p-values for each PC with a uniform distribution (dashed line). ‘Significant’ PCs will show a strong enrichment of features with low p-values (solid curve above the dashed line). 
```{r}
JackStrawPlot(emb.GFPpooled_v1, dims = 1:20)
ggsave("./Seurat_output/all_GFP_v1/emb.GFPpooled_v1.JackStrawPlot.png")


JackStrawPlot(emb.GFPpooled_v2, dims = 1:20)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.JackStrawPlot.png")
```


An alternative heuristic method generates an ‘Elbow plot’: a ranking of principle components based on the percentage of variance explained by each one.
```{r}
ElbowPlot(emb.GFPpooled_v1)
ggsave("./Seurat_output/all_GFP_v1/emb.GFPpooled_v1.ElbowPlot.png")


ElbowPlot(emb.GFPpooled_v2)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ElbowPlot.png")
```

The elbow plot is helpful when determining how many PCs we need to capture the majority of the variation in the data. The elbow plot visualizes the standard deviation of each PC. Where the elbow appears is usually the threshold for identifying the majority of the variation. However, this method can be a bit subjective about where the elbow is located.


# Cluster the cells
Seurat applies a graph-based clustering approach.

Seurat first constructs a KNN graph based on the euclidean distance in PCA space, and refines the edge weights between any two cells based on the shared overlap in their local neighborhoods (Jaccard similarity). This step is performed using the FindNeighbors() function, and takes as input the previously defined dimensionality of the dataset.

To cluster the cells, Seurat then applies modularity optimization techniques such as the Louvain algorithm (default) or SLM, to iteratively group cells together, with the goal of optimizing the standard modularity function. The FindClusters() function implements this procedure, and contains a resolution parameter that sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters.
```{r}
emb.GFPpooled_v1 <- FindNeighbors(emb.GFPpooled_v1, dims = 1:20)
emb.GFPpooled_v2 <- FindNeighbors(emb.GFPpooled_v2, dims = 1:20)

# deviation form original seurat pipeline
# generate a vector of different resolutions to see which one performs best 
emb.GFPpooled_v1.clust <- FindClusters(
  object = emb.GFPpooled_v1,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:20,
  save.SNN = TRUE)


emb.GFPpooled_v2.clust <- FindClusters(
  object = emb.GFPpooled_v2,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:20,
  save.SNN = TRUE)

## Now use Clustree to build a clustering tree based on the chosen resolutions specified above 
clustree(emb.GFPpooled_v1.clust, prefix = "RNA_snn_res.")
ggsave("./Seurat_output/all_GFP_v1/emb.GFPpooled_v1.Clustree.png")


clustree(emb.GFPpooled_v2.clust, prefix = "RNA_snn_res.")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.Clustree.png")

# can also see how the different resolutions look like this
DimPlot(emb.GFPpooled_v1.clust, group.by = "RNA_snn_res.0.8", label = TRUE)

# now choose the appropriate resolution for the given dimensions using the Clustree data
emb.GFPpooled_v1 <- FindClusters(emb.GFPpooled_v1, resolution = 1.2, cluster.name = "unintegrated_clusters")

emb.GFPpooled_v2 <- FindClusters(emb.GFPpooled_v2, resolution = 1.2, cluster.name = "unintegrated_clusters")
```

# Run non-linear dimensional reduction (UMAP or tSNE)
Visualize and explore data with UMAP or tSNE.
The goal of these algorithms is to learn the underlying manifold of the data in order to place similar cells together in low-dimensional space. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP or tSNE, it is suggested to use the same PCs as input to the clustering analysis.
```{r}
emb.GFPpooled_v1 <- RunUMAP(emb.GFPpooled_v1, dims = 1:20, reduction = "pca", reduction.name = "umap.unintegrated")
emb.GFPpooled_v2 <- RunUMAP(emb.GFPpooled_v2, dims = 1:20, reduction = "pca", reduction.name = "umap.unintegrated")
```

```{r}
# Note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters
DimPlot(emb.GFPpooled_v1, reduction = "umap.unintegrated", group.by = c("rep_group", "seurat_clusters"), label = "TRUE", label.box = TRUE, label.size = 3, pt.size = 1) + 
  theme(axis.title.x = element_text(size = 20),
        axis.ticks.x = element_line(size = 6),
        axis.title.y = element_text(size = 20),
        axis.ticks.y = element_line(size = 6),
        legend.text = element_text(size = 20))
ggsave("./Seurat_output/all_GFP_v1/emb.GFPpooled_v1.UMAP.unint.png")


DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", group.by = c("rep_group", "seurat_clusters"), label = "TRUE", label.box = TRUE, label.size = 3, pt.size = 1) + 
  theme(axis.title.x = element_text(size = 20),
        axis.ticks.x = element_line(size = 6),
        axis.title.y = element_text(size = 20),
        axis.ticks.y = element_line(size = 6),
        legend.text = element_text(size = 20))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.unint.png")

DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", group.by = c("rep_group", "seurat_clusters"))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.unint.png")

DimPlot(emb.GFPpooled_v2, reduction = "umap.unintegrated", split.by = "rep_group")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.unint.rep.png")
```



# Perform integration 
Aims to return a single dimensional reduction that captures the shared sources of variance across multiple layers, so that cells in a similar biological state will cluster. The method returns a dimensional reduction (i.e. integrated.cca, harmony) which can be used for visualization and unsupervised clustering analysis. 


Anchor-based CCA integration
```{r}
emb.GFPpooled_v1 <- IntegrateLayers(object = emb.GFPpooled_v1, method = CCAIntegration, orig.reduction = "pca", new.reduction = "integrated.cca",
    verbose = FALSE)

# re-join layers after integration
emb.GFPpooled_v1[["RNA"]] <- JoinLayers(emb.GFPpooled_v1[["RNA"]])

emb.GFPpooled_v1 <- FindNeighbors(emb.GFPpooled_v1, reduction = "integrated.cca", dims = 1:20)
emb.GFPpooled_v1 <- FindClusters(emb.GFPpooled_v1, resolution = 1.2, cluster.name = "cca_clusters")

emb.GFPpooled_v1 <- RunUMAP(emb.GFPpooled_v1, dims = 1:20, reduction = "integrated.cca", reduction.name = "umap.cca")

DimPlot(emb.GFPpooled_v1, reduction = "umap.cca", group.by = c("rep_group", "seurat_clusters"))

DimPlot(emb.GFPpooled_v1, reduction = "umap.cca", split.by = "rep_group")
ggsave("./Seurat_output/all_GFP_v1/emb.GFPpooled_v1.UMAP.int.cca.rep.png")
```
```{r}
emb.GFPpooled_v2 <- IntegrateLayers(object = emb.GFPpooled_v2, method = CCAIntegration, orig.reduction = "pca", new.reduction = "integrated.cca",
    verbose = FALSE)

# re-join layers after integration
emb.GFPpooled_v2[["RNA"]] <- JoinLayers(emb.GFPpooled_v2[["RNA"]])

emb.GFPpooled_v2 <- FindNeighbors(emb.GFPpooled_v2, reduction = "integrated.cca", dims = 1:20)
emb.GFPpooled_v2 <- FindClusters(emb.GFPpooled_v2, resolution = 1.2, cluster.name = "cca_clusters")

emb.GFPpooled_v2 <- RunUMAP(emb.GFPpooled_v2, dims = 1:20, reduction = "integrated.cca", reduction.name = "umap.cca")

DimPlot(emb.GFPpooled_v2, reduction = "umap.cca", group.by = c("rep_group", "seurat_clusters"))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.int.cca.png")

DimPlot(emb.GFPpooled_v2, reduction = "umap.cca", split.by = "rep_group")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.int.cca.rep.png")
```


Harmony
```{r}
#library(harmony)
```
```{r}
emb.GFPpooled_v1 <- IntegrateLayers(object = emb.GFPpooled_v1, method = HarmonyIntegration, orig.reduction = "pca", new.reduction = "harmony",
    verbose = FALSE)

# re-join layers after integration
emb.GFPpooled_v1[["RNA"]] <- JoinLayers(emb.GFPpooled_v1[["RNA"]])

emb.GFPpooled_v1 <- FindNeighbors(emb.GFPpooled_v1, reduction = "harmony", dims = 1:20)
emb.GFPpooled_v1 <- FindClusters(emb.GFPpooled_v1, resolution = 1.2, cluster.name = "harmony_clusters")

emb.GFPpooled_v1 <- RunUMAP(emb.GFPpooled_v1, dims = 1:20, reduction = "harmony", reduction.name = "umap.harmony")

DimPlot(emb.GFPpooled_v1, reduction = "umap.harmony", group.by = c("rep_group", "seurat_clusters"))

DimPlot(emb.GFPpooled_v1, reduction = "umap.harmony", split.by = "rep_group")
ggsave("./Seurat_output/all_GFP_v1/emb.GFPpooled_v1.UMAP.int.harmony.rep.png")
```
```{r}
emb.GFPpooled_v2 <- IntegrateLayers(object = emb.GFPpooled_v2, method = HarmonyIntegration, orig.reduction = "pca", new.reduction = "harmony",
    verbose = FALSE)

# re-join layers after integration
emb.GFPpooled_v2[["RNA"]] <- JoinLayers(emb.GFPpooled_v2[["RNA"]])

emb.GFPpooled_v2 <- FindNeighbors(emb.GFPpooled_v2, reduction = "harmony", dims = 1:20)
emb.GFPpooled_v2 <- FindClusters(emb.GFPpooled_v2, resolution = 1.2, cluster.name = "harmony_clusters")

emb.GFPpooled_v2 <- RunUMAP(emb.GFPpooled_v2, dims = 1:20, reduction = "harmony", reduction.name = "umap.harmony")

DimPlot(emb.GFPpooled_v2, reduction = "umap.harmony", group.by = c("rep_group", "seurat_clusters"), pt.size = 1)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.int.harmony.png")

DimPlot(emb.GFPpooled_v2, reduction = "umap.harmony", split.by = "rep_group")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.UMAP.int.harmony.rep.png")
```



# Identify conserved cell type markers across conditions
```{r}
#Idents(emb.GFPpooled_v1) <- "seurat_clusters"
#head(Idents(emb.GFPpooled_v1))

#conserved_markers <- FindConservedMarkers(emb.GFPpooled_v1, ident.1=6, grouping.var = "rep_group")

#view(conserved_markers)
```
```{r}
#Idents(emb.GFPpooled_v2) <- "seurat_annotations"
```


---

# Find differentially expressed features (cluster biomarkers)
Find markers that define clusters via differential expression. By default, Seurat identifies positive and negative markers of a single cluster compared to all other cells. You can do for all clusters, you can test groups of clusters vs. each other, or against all cells. 

The min.pct argument requires a feature to be detected at a minimum percentage in either of the two groups of cells, and the thresh.test argument requires a feature to be differentially expressed (on average) by some amount between the two groups. max.cells.per.ident can also be set and will downsample each identity class to have no more cells than whatever this is set to. 
```{r}
emb.GFPpooled_v2.markers <- FindAllMarkers(emb.GFPpooled_v2, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

emb.GFPpooled_v2.markers %>% 
  group_by(cluster) %>% filter(p_val_adj < .01) %>%
  slice_max(n = 2, order_by = avg_log2FC) 

write.csv(emb.GFPpooled_v2.markers,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2_markers.csv", row.names = TRUE)
```

```{r}
emb.GFPpooled_v2.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=2, wt=avg_log2FC) -> top2

emb.GFPpooled_v2.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=1, wt=avg_log2FC) -> top1

# Erin wants to see the smiFISH targets in the heat map as well
quartz(width = 20, height = 10)
DoHeatmap(emb.GFPpooled_v2, features = c(top1$gene), raster=F) + 
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.HeatMap-top1.png")

quartz(width = 20, height = 10)
DoHeatmap(emb.GFPpooled_v2, features = c(top1$gene, "clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F) + 
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.HeatMap-top1.smifish.png")

quartz(width = 20, height = 10)
DoHeatmap(emb.GFPpooled_v2, features = c("clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F) + 
  theme(axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.HeatMap-smiFISH.png")



# RNAi 
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.harmony", features = c("C14C6.5", "cpr-1", "Y32F6A.5", "endu-2", "clec-56", "pbo-4", "ugt-14"), ncol = 3)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.featureplot.rnai.png")

#intestine
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.harmony", features = c("elt-2", "elt-7", "end-1", "acp-2", "ges-1"), ncol = 2)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.featureplot.intestine.png")

# germline
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.harmony", features = c("glh-1", "chs-1"))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.featureplot.germ.png")

# neuron
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.harmony", features = c("hlh-2", "rab-3"))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.featureplot.neuron.png")

# muscle
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.harmony", features = c("myo-2", "myo-3"))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.featureplot.muscle.png")


# early intestine
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.harmony", features = c("end-1", "acp-2", "ugt-14"))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.featureplot.earlyint.png")
#-------------------- 

quartz(width = 10, height = 4)
FeaturePlot(emb.GFPpooled_v2, reduction = "umap.harmony", features = c("elt-2","elt-7",'ges-1',"end-1","acp-2","C10C5.4"),raster=F, ncol = 3) + 
  theme(axis.title.x = element_text(size = 12),
        axis.text.x = element_text(size = 14),
        axis.title.y = element_text(size = 12),
        axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeaturePlot-PosCtrls.png")



quartz(width = 10, height = 8)
FeaturePlot(emb.GFPpooled_v2, features = c("glh-1","chs-1", "myo-2", "myo-3", "hlh-2", "rab-3"), raster=F, ncol = 2) +
  theme(axis.title.x = element_text(size = 12),
        axis.text.x = element_text(size = 14),
        axis.title.y = element_text(size = 12),
        axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeaturePlot-NegCtrls.png")


#smiFISH targets
quartz(width = 5, height = 8)
FeaturePlot(emb.GFPpooled_v2, features = c("C14C6.5", "cpr-1", "Y32F6A.5", "endu-2", "clec-56", "pbo-4", "ugt-14"),raster=F, ncol = 3) +
  theme(axis.title.x = element_text(size = 12),
        axis.text.x = element_text(size = 14),
        axis.title.y = element_text(size = 12),
        axis.text.y = element_text(size = 14),
        legend.text = element_text(size = 14))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.FeaturePlot-FISH.png")
```


```{r}
#how many cells are expressing these markers of other tissues?
view(emb.GFPpooled_v2@assays$RNA$data)

total_cells_expressing_gene <- sum(emb.GFPpooled_v2@assays$RNA$data["hlh-2", ] > 0)
print(total_cells_expressing_gene)

total_cells_expressing_gene <- sum(emb.GFPpooled_v2@assays$RNA$data["myo-3", ] > 0)
print(total_cells_expressing_gene)

total_cells_expressing_gene <- sum(emb.GFPpooled_v2@assays$RNA$data["rab-3", ] > 0)
print(total_cells_expressing_gene)
```


# Perform gene ontology
```{r}
library(reticulate)
py_config()
# to modify the python to use in R, nano ~/.Renviron. just uncomment the right path and comment out the other. Will need to restart the Rsession before implimenting. 
use_condaenv("base")

tea <- import("tissue_enrichment_analysis")
tissue_df <- tea$fetch_dictionary("tissue")
phenotype_df <- tea$fetch_dictionary("phenotype")
go_df <- tea$fetch_dictionary("go")

#set up go_df to represent only our background genes 
#view(go_df) 
#dim(go_df)

#go_df <- go_df %>% rename(WBGeneID = wbid)
#go_df_background <- go_df %>% filter(WBGeneID %in% emb.ALLpooled.markers$WBGeneID)
#go_df_background <- go_df_background %>% rename(wbid = WBGeneID)


#tissue_df <- tissue_df %>% rename(WBGeneID = wbid)
#tissue_df_background <- tissue_df %>% filter(WBGeneID %in% emb.ALLpooled.markers$WBGeneID)
#tissue_df_background <- tissue_df_background %>% rename(wbid = WBGeneID)
```

```{r}
emb.GFPpooled_v2.markers <- emb.GFPpooled_v2.markers %>% left_join(genes.df, by = c("gene" = "external_gene_id")) 
emb.GFPpooled_v2.markers <- emb.GFPpooled_v2.markers %>% rename(WBGeneID = wbps_gene_id)
```

```{r}
clusters <- unique(emb.GFPpooled_v2.markers$cluster)

my_tea_analysis <- function(input_df, tea_dict){
  tea_df <- data.frame()
  for (i in clusters){
  tea_set <- tea$enrichment_analysis(
    (input_df %>% 
       filter(cluster == i))$WBGeneID, 
    tissue_df = tea_dict 
  )
  if(nrow(tea_set) == 0){
    next
  } else {
  tea_df <- bind_rows(tea_df, data.frame(tea_set, cluster = i))
  }
}
tea_df
}

reorder_within <- function(x, by, within, fun = mean, sep = "___", ...) {
    new_x <- paste(x, within, sep = sep)
    stats::reorder(new_x, by, FUN = fun)
}

scale_x_reordered <- function(..., sep = "___") {
    reg <- paste0(sep, ".+$")
    ggplot2::scale_x_discrete(labels = function(x) gsub(reg, "", x), ...)
}

my_ontology_plot <- function(input_df, xlabel){
  input_df %>%
  filter(Q.value < 0.001,  Observed > 10) %>% 
  ggplot(aes(x = reorder_within(Term, -log10(Q.value), cluster), y = -log10(Q.value))) +
  geom_point(aes(size = Observed)) +
  coord_flip() +
  scale_x_reordered() +
  facet_wrap(cluster~., ncol = 3, scales = "free_y") +
  theme_bw() +
  xlab(xlabel) +
  guides(size = guide_legend(title = "# genes")) +
  scale_size_continuous(breaks = c(10,20,100,200,300))
}
```

```{r}
#filter(Q.value < 0.001,  Observed > 50)

quartz(width = 10, height = 20)
my_ontology_plot(my_tea_analysis(emb.GFPpooled_v2.markers %>% filter(p_val_adj < 0.01, avg_log2FC > 2), tissue_df), "Tissue Ontology")

ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.GO_T.png", limitsize = FALSE)
```

```{r}
#filter(Q.value < 0.001,  Observed > 10)

quartz(width = 60, height = 40)
my_ontology_plot(my_tea_analysis(emb.GFPpooled_v2.markers %>% filter(p_val_adj < 0.01, avg_log2FC > 2), go_df), "Gene Ontology") + theme(text = element_text(size = 30))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.GO_G.png", limitsize = FALSE)
```

```{r}
# #filter(Q.value < 0.001,  Observed > 10)
# 
# quartz(width = 60, height = 40)
# my_ontology_plot(my_tea_analysis(emb.GFPpooled.markers %>% filter(p_val_adj < 0.04, avg_log2FC > 1), go_df_background), "Gene Ontology") + theme(text = element_text(size = 30))
# 
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.GO_G_background.png", limitsize = FALSE)
```
```{r}
# #filter(Q.value < 0.001,  Observed > 10)
# 
# quartz(width = 60, height = 100)
# my_ontology_plot(my_tea_analysis(emb.GFPpooled.markers %>% filter(p_val_adj < 0.04, avg_log2FC > 1), tissue_df_background), "Gene Ontology") + theme(text = element_text(size = 30))
# 
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.GO_T_background.png", limitsize = FALSE)
```

# plot genes of interest
From John Murray dataset 
    - intestine_anterior: ZC204.12, cpr-1, ceh-37
    - intestine_middle_and_posterior: irg-7, pal-1, cpr-1, ceh-37
    - intestine_far_posterior: irg-7, faah-1, pbo-4, psa-3
```{r}
# # top marker gene for each cluster
# FeaturePlot(emb.GFPpooled, pt.size = 0.1,
#             features = (emb.GFPpooled.markers %>% group_by(cluster) %>% slice_max(n = 1, order_by = avg_log2FC))$gene)
```

```{r}
# # genes from murray data
# # intestine_anterior
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('ZC204.12', 'cpr-1', 'ceh-37'), raster=F, ncol = 1) +
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.Murray-Anterior.png") 
# 
# # intestine_middle_and_posterior
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('irg-7', 'pal-1', 'cpr-1', 'ceh-37'), raster=F, ncol = 1) + 
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.Murray-Mid.png")
# 
# # intestine_far_posterior
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('faah-1', 'pbo-4', 'psa-3'), raster=F, ncol = 1) + 
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.Murray-Posterior.png")
```

```{r}
# # marker genes we FISHed for
# quartz(width = 5, height = 10)
# FeaturePlot(emb.GFPpooled, features = c('C14C6.5', 'clec-56', 'pbo-4'), raster=F, ncol = 1) + 
#   theme(axis.title.x = element_text(size = 12),
#         axis.text.x = element_text(size = 14),
#         axis.title.y = element_text(size = 12),
#         axis.text.y = element_text(size = 14),
#         legend.text = element_text(size = 14))
# ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.smiFISH-genes.png")
```

-------------------------------NOT USING RIGHT NOW-----------------------
# Remove contamination clusters
contamination clusters = 6, 12, 20
```{r}
emb.GFPpooled_v2.specificClusters <- RunUMAP(subset(emb.GFPpooled_v2, idents = c('6','12', '20'), invert = TRUE), dims = 1:20)
```
# now rerun PCA and re-lcuster 
```{r}
emb.GFPpooled_v2.specificClusters <- RunPCA(emb.GFPpooled_v2.specificClusters, features = VariableFeatures(object = emb.GFPpooled_v2.specificClusters))

DimPlot(emb.GFPpooled_v2.specificClusters, reduction = "pca")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.DimPlot.png")

ElbowPlot(emb.GFPpooled_v2.specificClusters)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.ElbowPlot.png")
```
```{r}
# Choose the number of PCs to use for re-clustering 
emb.GFPpooled_v2.specificClusters <- FindNeighbors(emb.GFPpooled_v2.specificClusters, dims = 1:7)

# check new clusters with Clustree
emb.GFPpooled_v2.specificClusters.recluster <- FindClusters(
  object = emb.GFPpooled_v2.specificClusters,
  reduction.type = "pca",
  resolution = c(0.2, 0.4, 0.8, 1, 1.2),
  dims.use = 1:7,
  save.SNN = TRUE)

clustree(emb.GFPpooled_v2.specificClusters.recluster, prefix = "RNA_snn_res.")
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.Clustree.png")

emb.GFPpooled_v2.specificClusters.recluster <- FindClusters(emb.GFPpooled_v2.specificClusters, resolution = 1.2)

emb.GFPpooled_v2.specificClusters.recluster <- RunUMAP(emb.GFPpooled_v2.specificClusters.recluster, dims = 1:7)

DimPlot(emb.GFPpooled_v2.specificClusters.recluster, reduction = "umap", group.by = c("rep_group", "seurat_clusters"), pt.size = 1) + theme(legend.text = element_text(size = 15))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.UMAP.png") 

DimPlot(emb.GFPpooled_v2.specificClusters.recluster, reduction = "umap", split.by = c("rep_group"), pt.size = 1) + theme(legend.text = element_text(size = 15))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.UMAP.rep.png") 
```

# Find new marker genes
```{r}
#find markers for every cluster compared to all remaining cells
emb.GFPpooled_v2.specificClusters.recluster.markers <- FindAllMarkers(emb.GFPpooled_v2.specificClusters.recluster, only.pos = F, min.pct = 0.25, logfc.threshold = 1)

emb.GFPpooled_v2.specificClusters.recluster.markers %>% 
  group_by(cluster) %>%
  slice_max(n = 2, order_by = avg_log2FC)

write.csv(emb.GFPpooled_v2.specificClusters.recluster.markers,"./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.markers.csv", row.names = TRUE)
```


# Validate clusters 
```{r}
emb.GFPpooled_v2.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=1, wt=avg_log2FC) -> top1_reclust

DoHeatmap(emb.GFPpooled_v2.specificClusters.recluster, features = top1_reclust$gene,raster=F) + theme(text = element_text(size = 20))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.HeatMap-top1.png") 

DoHeatmap(emb.GFPpooled_v2.specificClusters.recluster, features = c(top1_reclust$gene, "clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F) + theme(text = element_text(size = 20))
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.HeatMap-top1.fish.png") 


# intestine marker genes
FeaturePlot(emb.GFPpooled_v2.specificClusters.recluster, features = c("elt-2","elt-7", 'ges-1'),raster=F, ncol = 2)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.FeaturePlot-PostCtrls.png")

# Contamination marker genes: germline (glh-1, chs-1), muscle (myo-2, myo-3), neuron(hlh-2, rab-3)  
FeaturePlot(emb.GFPpooled_v2.specificClusters.recluster, features = c("glh-1","chs-1", "myo-2", "myo-3", "hlh-2", "rab-3"), raster=F, ncol = 2)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.FeaturePlot-NegCtrls.png")


# FISH
FeaturePlot(emb.GFPpooled_v2.specificClusters.recluster, features = c("clec-56", "pbo-4", "C14C6.5", "ugt-14", "endu-2", "cpr-1", "Y32F6A.5"), raster=F, ncol = 3)
ggsave("./Seurat_output/all_GFP_v2/emb.GFPpooled_v2.ContaminationRemoved.FeaturePlot-FISH.png")
```


# Perform gene ontology
```{r}
library(reticulate)
py_config()
# to modify the python to use in R, nano ~/.Renviron. just uncomment the right path and comment out the other. Will need to restart the Rsession before implimenting. 
use_condaenv("base")

tea <- import("tissue_enrichment_analysis")
tissue_df <- tea$fetch_dictionary("tissue")
phenotype_df <- tea$fetch_dictionary("phenotype")
go_df <- tea$fetch_dictionary("go")
```

```{r}
emb.GFPpooled.specificClusters.recluster.markers <- emb.GFPpooled.specificClusters.recluster.markers %>% left_join(genes.df, by = c("gene" = "external_gene_id")) 

emb.GFPpooled.specificClusters.recluster.markers <- emb.GFPpooled.specificClusters.recluster.markers %>% rename(WBGeneID = wbps_gene_id)
```

```{r}
clusters <- unique(emb.GFPpooled.specificClusters.recluster.markers$cluster)

my_tea_analysis <- function(input_df, tea_dict){
  tea_df <- data.frame()
  for (i in clusters){
  tea_set <- tea$enrichment_analysis(
    (input_df %>% 
       filter(cluster == i))$WBGeneID, 
    tissue_df = tea_dict 
    # %>% 
    #   filter(wbid %in% (input_df %>% 
    #                       filter(cluster %in% clusters))$WBGeneID)
  )
  if(nrow(tea_set) == 0){
    next
  } else {
  tea_df <- bind_rows(tea_df, data.frame(tea_set, cluster = i))
  }
}
tea_df
}

reorder_within <- function(x, by, within, fun = mean, sep = "___", ...) {
    new_x <- paste(x, within, sep = sep)
    stats::reorder(new_x, by, FUN = fun)
}

scale_x_reordered <- function(..., sep = "___") {
    reg <- paste0(sep, ".+$")
    ggplot2::scale_x_discrete(labels = function(x) gsub(reg, "", x), ...)
}

my_ontology_plot <- function(input_df, xlabel){
  input_df %>%
  filter(Q.value < 0.001,  Observed > 50) %>% 
  ggplot(aes(x = reorder_within(Term, -log10(Q.value), cluster), y = -log10(Q.value))) +
  geom_point(aes(size = Observed)) +
  coord_flip() +
  scale_x_reordered() +
  facet_grid(cluster~., scales = "free_y") +
  theme_bw() +
  xlab(xlabel) +
  guides(size = guide_legend(title = "# genes")) +
  scale_size_continuous(breaks = c(20,100,200))
}
```

```{r fig.height=15, fig.width=5}
my_ontology_plot(my_tea_analysis(emb.GFPpooled.specificClusters.recluster.markers %>% filter(p_val_adj < 0.05, avg_log2FC > 1), tissue_df), "Tissue Ontology")

ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.GO_T.png")
```

```{r fig.height=15, fig.width=5}
my_ontology_plot(my_tea_analysis(emb.GFPpooled.specificClusters.recluster.markers %>% filter(p_val_adj < 0.05, avg_log2FC > 1.01), go_df), "Gene Ontology") + theme(text = element_text(size = 15))

ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.GO_G.png")
```


# Pull out new cluster marker genes 
```{r}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(p_val_adj < .01) %>% top_n(n=4, wt=avg_log2FC) -> top4

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top4$gene,raster=F)

ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top4.png")
```


# Pull out new cluster specific CLECs 
```{r}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(grepl("clec*",gene), p_val_adj < .01) %>% top_n(n=2, wt=avg_log2FC) -> top2clecs

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top2clecs$gene,raster=F)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top2clecs.png")
```


# Pull out cluster specific SPPs 
```{r fig.height=4, fig.width=7}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(grepl("^spp",gene), p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10spps

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top10spps$gene,raster=F)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top10spp.png")
```

# Pull out cluster specific IRGs 
```{r fig.height=4, fig.width=7}
emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% filter(grepl("^irg",gene), p_val_adj < .01) %>% top_n(n=10, wt=avg_log2FC) -> top10irgs

DoHeatmap(emb.GFPpooled.specificClusters.recluster, features = top10irgs$gene,raster=F)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.HeatMap-top10irg.png")
```



# plot genes of interest
From John Murray dataset 
    - intestine_anterior: ZC204.12, cpr-1, ceh-37
    - intestine_middle_and_posterior: irg-7, pal-1, cpr-1, ceh-37
    - intestine_far_posterior: irg-7, faah-1, pbo-4, psa-3

```{r}
# top marker gene for each cluster
FeaturePlot(emb.GFPpooled.specificClusters.recluster, pt.size = 0.1,
            features = (emb.GFPpooled.specificClusters.recluster.markers %>% group_by(cluster) %>% slice_max(n = 1, order_by = avg_log2FC))$gene)
```

```{r}
# genes from murray data
# intestine_anterior
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('ZC204.12', 'cpr-1', 'ceh-37'), raster=F, ncol = 2)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.Murray-Anterior.png") 

# intestine_middle_and_posterior
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('irg-7', 'pal-1', 'cpr-1', 'ceh-37'), raster=F, ncol = 2)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.Murray-Mid.png")

# intestine_far_posterior
FeaturePlot(emb.GFPpooled.specificClusters.recluster, features = c('faah-1', 'pbo-4', 'psa-3'), raster=F, ncol = 2)
ggsave("./Seurat_output/GFP_pooled/emb.GFPpooled.ContaminationRemoved.Murray-Posterior.png")
```



# Assign cell type identity to clusters 
```
new.cluster.ids <- c("Naive CD4 T", "CD14+ Mono", "Memory CD4 T", "B", "CD8 T", "FCGR3A+ Mono",
    "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

